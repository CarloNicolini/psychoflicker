 function MotHemifield_TMS_01()% <zz<zzz<<<zz<z<<z<z<z<<z<<z<<z<<<<<<zzqqqnmnmnmnnmmmnnmmnmmnmmnnnmmmmnmnmnnmnmmnmnmmnmmnmmn mmm nnmqzmnmnnmmnnnmnmnnnnmmmmnmnmmnnnnnmmnnmnmmnnmnmnnm m mmmm m  m   m  m  ,..,,.-..,,,.,..,...,......,,..,,,..,..,,,,,....,.  .-.-..---.--.--...---..-..  .---.-......---.-qq  .....   . ..    ...  .... function MotHemifield_fMRI()% klkkl ,...,..,,..,,,.,,,...,.,...,,...,..,.,,,,,,,,,,.., lllkllkklkkklklkkkkklkllkkklklkkkkklkklkkkkll % George  ,. nmnnnmnnnnnnnnmnnnnmnnnmnm,...,.,,,..,,,,,,,,,.,,,.,,,.,...,,...,...,.,., Alvarez: alvarez@mit.edu% Based On: MotTemplatePI v1.0% Version: 1.0% Last Modified: 11 <zzzzz<<<<<zzzz<zzzzzz<<<<z<<<z<<z<<<<z<<<<<<<<<zz .09.2005% ********** %% ********** Return Values% none.% **********%% ********** Purpose (what this function does)% Setup for fMRI, to determine whether there is any region of the parietal% cortex that is sensitive to the tracking load in the contralateral% hemifield more than within the ipsilateral hemifield. % **********%% ********** %Updates%% 11.09.2005, version 1.0, by GAA - first draft%% **********% ********** Outline (Program Structure)%% This function is broken down into 3 sections, each with several steps%% I. SETUP%       1. RESET MATLAB                             : clear varibles, set random seed%       2. DEFINE GLOBAL VARIABLES                  : variables shared with subfunctions%       3. GET INPUT VARIABLES                      : user input%       4. SET/INITIALIZE VARIABLES                 : setting some global variables, getting directories, etc.%       5. SCREEN SETUP                             : intialize main screen%       and buffers%       6. EXPERIMENT SETUP                         : coordinates, colors, keys, etc.%%% II. RUN EXPERIMENT%%       Run Blocks of Trials, Each With the Following Steps%%       1.  Initiate Trial                          : wait for keypress to initiate a trial%       2.  Hide Mouse                              : make sure the mouse isn't in the middle of the screen%       3.  Get Current Trial Type                  : set variables for current trial%       4.  Prepare Trial According to Trial Type   : determine identity and location of items, etc.%       5.  Display Stimuli                         : draw/display stimuli%       6.  Collect Response                        : check for a response (keypress, mouseclick, etc.)%       7.  Check for Quit Key                      : if quit, return%       8.  Record Trial Results                    : print results to file%% III. ANALYZE DATA%%       1. Compute Summary Statistics               : get average RT, error for conditions%       2. Save Final Results                       : save some summary stats%       3. Close Data File and Screens              : close files and screens%%% IV. SUBFUNCTIONS%%       1. General Functions (e.g., getting random integers)%       2. Experiment Functions (used to setup and run experiment)%       3. MAC OSX, OS9, WINDOWS Compatability (functions required to make program run on all of these platforms without changing body of experiment)%% **********% I. SETUP *****************************************************************************************************************************************% 1. RESET MATLAB ---------------------Priority(0);warning off MATLAB:DeprecatedLogicalAPI  % only for PCclear all;                      % clear everythingrand('state',sum(100*clock));   % set the state of the random number generator to some random value (based on the clock)%--------------------------------------% 2. DEFINE GLOBAL VARIABLES ----------% main screenglobal win1 screenNumber screenX screenY centerX centerY screenRect activeRect% offscreen windows/texturesglobal quitWin blankWin fixWin tempWin trialWin stimulusWin drawWin endWinglobal quitTexture blankTexture fixTexture tempTexture endTexture blankTexture fixTexture stimulusTexture  trialTexture% tracking parametersglobal ITEMSIZE ITEMSPEED MAXTARGETS% item locationsglobal LEFT RIGHT TOP BOTTOM% item identitiesglobal itemColor itemCorrectColor itemIncorrectColor itemBlankColor% response keysglobal whichKeyboard Key1 Key2 QuitKey % subject response/accuracyglobal startTime RT response trackError numberCorrect percentCorrectglobal itemLeft itemRight itemTop itemBottomglobal fid filename expname sinit condnum condname numItems numTargets redgreen yesno probefield currTrial currBlock numBlocks numTrials numTrialsPerBlock currType randomsequence numtypesglobal condnumArray condnameArray numTargetsArray redgreenArray yesnoArray trackRTArray trackErrorArray numCorrectArray percentCorrectArrayglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir movieDir loadTrajectoryDir saveTrajectoryDirglobal jpgFiles numImages imageArrayglobal itemCoordinates_h itemCoordinates_v itemGoalPos itemGoalH itemGoalV itemDirection itemSpeed itemSize itemShape itemIsTarget itemIsProbeglobal runMode saveTrajectory makeMovie saveTrajectories FILE_TRAJECTORIESglobal uniqueIDglobal itemIsSelected numCorrectSoFar numSoFar clickAccuracy clickRT screenNumber responseModeglobal meanPercentCorrect meanError meanHitRate meanFARate CapacityVsNumTargets AsymptoteEstimateglobal DisplayDuration NewFrameTime NewRefreshRate DrawTime numberDroppedglobal trajFileNameglobal frameCount blinkFramesglobal QUADSIZE INSET LLEFT LRIGHT LTOP LBOTTOM RLEFT RRIGHT RTOP RBOTTOM LRECT RRECT AREARECTglobal ExperimentStartTime BlockStartTime TrialStartTime FixationDuration BlinkDuration TrackDuration ResponseDuration TrialDuration FeedbackDurationglobal win1 RefreshRateglobal TextFontSize FixSize ShowFramesglobal TWOTARGETSPEED FOURTARGETSPEED%--------------------------------------% 3. GET INPUT VARIABLES --------------% user promptprompt={'Experiment Name:';'Subject code:'; 'Threshold Speeds'; 'Number of Blocks'; 'Run From Files (1), Run Online (2), Compute Only (3)';'Click Targets (1), Which Target (2), Target/Distractor (3)'; 'Save Trajectories (0=off, 1=on)'; 'Make Movie (0=off, 1=on)'};def={'MOT_TMS';'S99'; '[8 6]'; '1';'2'; '3'; '0';'0'};title='Input Variables';lineNo=1;userinput=inputdlg(prompt,title,lineNo,def);% enter input into variablesexpname=userinput{1};sinit=userinput{2};thresholdSpeeds=str2num(char(userinput(3)));numBlocks=str2num(char(userinput(4)));runMode=str2num(char(userinput(5)));responseMode=str2num(char(userinput(6)));saveTrajectory=str2num(char(userinput(7)));makeMovie=str2num(char(userinput(8)));%--------------------------------------% 4. SET/INITIALIZE VARIABLES ---------% timing parametersFixationDuration  =   1;BlinkDuration     =   2;TrackDuration     =   6;ResponseDuration  = 2.5;FeedbackDuration  =  .5;TrialDuration     = FixationDuration+BlinkDuration+TrackDuration+ResponseDuration% motion parametersTWOTARGETSPEED  = thresholdSpeeds(1)FOURTARGETSPEED = thresholdSpeeds(2)ITEMSIZE    = 20;ITEMSPEED   = 16.5;MAXTARGETS  = 5;QUADSIZE    = 300;INSET       = 64;% miscTextFontSize = 36;FixSize      = 5;ShowFrames   = 0;% blocks/trialscurrTrial = 0;currBlock = 0;numTrials =48;numTrialsPerBlock = 48;% set directory, open data file kl kllkkkklklllllklllkllklklk% klklkklkkkllllklkklkklkllk  nmnnnmnmmmmmnnnmnmmnmnnmnnGetDirectories;% setup results fileSetupResults;%--------------------------------------% 5. SCREEN SETUP ---------------------%basic drawing and screen variablesblack       =0;white       =255;bcolor      =[127 127 127];fontsize    =25;%main gray window with a fixation pointscreens=Screen('Screens');screenNumber=max(screens);%screenNumber=min(screens);% open the mainscreen windowOpenMainWindow;[sourceFactorOld, destinationFactorOld]=Screen('BlendFunction', win1, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);GetRefreshRate;% find center of mainscreencenterX = screenX/2;centerY = screenY/2;LEFT    = centerX - 500/2;RIGHT   = centerX + 500/2;TOP     = centerY - 500/2;BOTTOM  = centerY + 500/2;LLEFT   = centerX - QUADSIZE - INSET;LRIGHT  = centerX - INSET;LTOP    = centerY - QUADSIZE/2;LBOTTOM = centerY + QUADSIZE/2;RLEFT   = centerX + INSET;RRIGHT  = centerX + QUADSIZE + INSET;RTOP    = centerY - QUADSIZE/2;RBOTTOM = centerY + QUADSIZE/2;LRECT   = [LLEFT LTOP LRIGHT LBOTTOM];RRECT   = [RLEFT RTOP RRIGHT RBOTTOM];AREARECT= [LLEFT-ITEMSIZE/2 LTOP-ITEMSIZE/2 RRIGHT+ITEMSIZE/2 LBOTTOM+ITEMSIZE/2];    activeRect = [centerX-centerY centerY-centerY centerX+centerY centerY+centerY];% draw a fixation point on mainscreenFillRect(win1, bcolor,screenRect);FillOval(win1, [0 0 0], [centerX-5 centerY-5 centerX+5 centerY+5]);% show the main screen and hide the mouseShowMain;SetMouse(screenRect(3),screenRect(4),win1); %move to bottom right corner (I find Hidecursor unreliable)% open a blank screenblankWin=OpenOffscreenWindow(win1,[],screenRect,32);FillRect(blankWin,bcolor,screenRect);blankTexture=MakeTexture(blankWin, [centerX-centerY centerY-centerY centerX+centerY centerY+centerY]);% open blank screen with fixation pointfixWin=OpenOffscreenWindow(win1,[],screenRect,32);FillRect(fixWin, bcolor,screenRect);FillOval(fixWin, [0 0 0], [centerX-FixSize centerY-FixSize centerX+FixSize centerY+FixSize]);if (ShowFrames)    FrameRect(fixWin,[0 0 0],LRECT);    FrameRect(fixWin,[0 0 0],RRECT);    FrameRect(fixWin,[0 0 0],AREARECT);endfixTexture=MakeTexture(fixWin, [centerX-centerY centerY-centerY centerX+centerY centerY+centerY]);% another blank window for drawing to the main screentempWin=OpenOffscreenWindow(win1,[],screenRect,32);% stimulus windowstimulusWin(1)=OpenOffscreenWindow(win1,[],screenRect,32);% open a screen with "Press Any Key" messagetrialWin=OpenOffscreenWindow(win1,[],screenRect,32);FillRect(trialWin,bcolor,screenRect);TextSize(trialWin,TextFontSize);textStr = 'PRESS ANY KEY TO START NEXT TRIAL';[textX, textY] = CenterText(trialWin,screenRect,textStr,36);DrawText(trialWin, textStr, textX, textY, [0 0 0]);trialTexture=MakeTexture(trialWin, activeRect);% determine which window to draw toGetDrawWindow;%--------------------------------------% 5. EXPERIMENT SETUP -----------------% load image files (if any)%LoadImageFiles(0);% Get a Keyboard (in case there are multiple keyboards)GetKeyboard;% Get Response Keys (this function makes it easy to counterbalance handedness of response)GetKeys;% Setup Coordinates (choose a layout)LAYOUT		 			= 4;  	% 1 is for grid, 2 is for circular array, 3 is for brut force positioning, 4 is for regular hemifield coordinates, and 5 is for attn crowding scaled hemifield coordinatesHORIZONTAL_POSITIONS	= 4;    % if layout = grid, number of positions in horizontal directionVERTICAL_POSITIONS		= 4;    % if layout = grid, number of positions in vertical directionRESERVE_FIXATION		= 1;    % if layout = grid, whether the center cell (if there is one), should be reserved for a fixation point, 0 for no, 1 for yesHORIZONTAL_EXTENT		= 600;  % if layout = grid, width of gridVERTICAL_EXTENT			= 600;  % if layout = grid, height of gridNUM_POSITIONS			= 36; 	% if layout = circular array, the number of locationsRADIUS					= 96;	% if layout = circular array, distance from fixation to the center of each locationSPACING					= 48;	% pixels separating each cell of the gridX_SIZE                  = 32;   % approximate horizontal size of stimuli, to calculate jitterY_SIZE      			= 32;	% approximate vertical size of stimuli, to calculate jitterJITTER					= 1;    % 1 = jitter items, 0 = no jitterHEMI_BUFFER				= 72;   % buffer (blank space) at vertical and horizontal midlineHEMI_NUM_RINGS			= 3;    % number of ringsHEMI_NUM_PER_RING		= 3;    % number of items per ring, per hemisphereSetupCoordinates(1);            % sets up locations using above parameters, (input is whether or not to show a preview of the layout, 1 = yes)% number of trials typesnumtypes                = 10;   % number of different trial types%--------------------------------------% **************************************************************************************************************************************************% II. RUN THE EXPERIMENT ***************************************************************************************************************************if (runMode <= 2) % Running Trials From Files or Online        %WaitForTrigger;    ExperimentStartTime=GetSecs;        for currBlock=1:numBlocks                BlockStartTime(currBlock)=GetSecs;                % Initiate Block ------------------------------------------        InitBlock(0);                                               %randomize trial order, inform user of current block number, wait for key press        %----------------------------------------------------------        for trial=1:numTrialsPerBlock                                    % 1. Initiate Trial -----------------------------------            InitTrial(0, trial);                                    %waitfor keypress (1), or just go (0)            TrialStartTime(currTrial)=GetSecs;            %------------------------------------------------------            % 2. Make Sure Mouse Isn't On Screen ------------------            SetMouse(screenRect(3),screenRect(4),win1);             %move to bottom right corner (I find Hidecursor unreliable)            %------------------------------------------------------            % 3. Get Current Trial Type ---------------------------            GetTrialType(trial);                                    %determine set variables for current trial            %------------------------------------------------------            % 4. Prepare Trial According to Trial Type-------------            PrepareTrial;                                           %get item positions/identities            %------------------------------------------------------            % 5. Display Stimuli ----------------------------------            DisplayStimuli;                                         %display stimuli on main screen                        % just end if making a movie            if (makeMovie)                SaveFinalMovieFrame;                fclose(fid);                Priority(0);                clear all;                return;            end            %------------------------------------------------------                        % 6. Collect Response ---------------------------------            GetTrackingResponse;                                % get tracking response            %------------------------------------------------------            % 7. Check for Quit Key -------------------------------            if (response == QuitKey)                DoubleCheckQuitKey;                if (response == QuitKey)                    fclose(fid);                     Priority(0);                    clear all;                    return;                end            end            %------------------------------------------------------            % 8. Record Trial  ------------------------------------            RecordTrialResults;                                     %record results in text file, and save trial variables/trajectories (to be used to analyze data and save in a .mat file at the end of the experiment)            %------------------------------------------------------            TrialEndTime(currTrial)=GetSecs;            TrialTime(currTrial)=TrialEndTime(currTrial)-TrialStartTime(currTrial);        end        BlockEndTime(currBlock)=GetSecs;        BlockDuration(currBlock)=BlockEndTime(currBlock)-BlockStartTime(currBlock);    endelse    % Just Compute Trajecotry Files    for currBlock=1:numBlocks        % Initiate Block ------------------------------------------        InitBlock(0);                                               %randomize trial order, inform user of current block number, wait for key press        %----------------------------------------------------------        for trial=1:numTrialsPerBlock            % 1. Increment Trial Count ----------------------------            currTrial=currTrial+1;                                  %determine set variables for current trial            %------------------------------------------------------                                    % 2. Get Current Trial Type ---------------------------            GetTrialType(trial);                                    %determine set variables for current trial            %------------------------------------------------------                        % 3. Prepare Trial According to Trial Type-------------            PrepareTrial;                                           %get item positions/identities            %------------------------------------------------------                        % 4. Compute/Save Trials ------------------------------            cd(loadTrajectoryDir);            numFrames=600;            for i=1:numFrames                ComputeFrame(i);                                    % compute current frame (e.g., item locations/appearance)            end            trajFileName=['TrackFile_' num2str(currTrial) '.mat'];            genCenterX=centerX; % save center position (in case different resolution used when running from this file)            genCenterY=centerY; % saving with new name so wont overwrite actual centerX, centerY when loaded            save (trajFileName, 'FILE_TRAJECTORIES', 'itemIsTarget', 'itemIsProbe', 'genCenterX', 'genCenterY'); % with this info should be able to reproduce trajectories exactly!            %------------------------------------------------------                        % 5. Show Experimenter Statu --------------------------            FillRect(win1,bcolor,screenRect);            TextSize(win1,TextFontSize);            textStr = ['SAVING FILE #' num2str(currTrial) ' OUT OF ' num2str(numTrials)];            [textX, textY] = CenterText(win1,screenRect,textStr,36);            DrawText(win1, textStr, textX, textY, [0 0 0]);            ShowScreen(win1, screenRect);            %------------------------------------------------------        end    end    endExperimentEndTime=GetSecs;ExperimentDuration=ExperimentEndTime-ExperimentStartTime;TrialTimeBlockDurationmean(TrialTime)mean(BlockDuration)ExperimentDuration% **************************************************************************************************************************************************% III. ANALYZE THE DATA ****************************************************************************************************************************if (runMode <= 2)    EndOfSessionMessage;            % end of session    ClearKeys;                      % clear command window    %ComputeSummaryStatistics;       % compute means, etc., draw figure    SaveFinalResults;               % save all data in a .mat file, and save the analysis output as a separate .mat file    fclose(fid);                    % close data file    Screen('CloseAll');             % close all windowselse    ClearKeys;                      % clear command window    fclose(fid);                    % close data file    Screen('CloseAll');             % close all windowsend% **************************************************************************************************************************************************% **********************%%        THE END        %% **********************%% **************************************************************************************************************************************************% **************************************************************************************************************************************************%%                               SUBFUNCTIONS%% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function [number] = randInt(min,max)% purpose: generate a random number, with equal likelihood of values between min and maxnumber = min + floor ( rand * ( max + 1 - min ) );% -------------------------------------------------------------------------% -------------------------------------------------------------------------function [frames] = msecsToFrames(msecs)global RefreshRate% purpose: generate a random number, with equal likelihood of values between min and maxframes = msecs/(1/RefreshRate*1000);% -------------------------------------------------------------------------function [x,y,buttons] = GetMouseMulti(windowPtrOrScreenNumber)% function [x,y,buttons] = GetMouseMulti(windowPtrOrScreenNumber)% George Alvarez: alvarez@mit.edu% Version: 1.0% Last Modified: 10.17.2005% Demo:% [x,y,buttons] = GetMouseMulti(0);% while ~any(buttons)%   [x,y,buttons]= GetMouseMulti(0)% end% This demo gets coordinates of mouse relative to main screen.% ********** Input Variables% windowPtrOrScreenNumber=which screen% **********% ********** Return Values% x: x position of mouse% y: y position of mouse% buttons: whether button is pressed (0=no, 1=yes), one column for each% button on the mouse...% **********% ********** Purpose (what this function does)% This function is a hack which avoids the "multiple mouse" error that you% get when using GetMouse.% **********% ********** Outline% This function is broken down into 2 main steps% 1. initialize some variables% 2. get mouse position, correct for% **********% 1. Initialize Some Variables ********************************************%get the number of mouse buttons from PsychHIDmousedices=GetMouseIndices;numMice = length(mousedices);%to avoid multiple mouse problemmousedices = mousedices(1);% *************************************************************************% 2. Get Mouse Position ***************************************************allHidDevices=PsychHID('Devices');numMouseButtons=allHidDevices(mousedices).buttons;%read the mouse position and  buttons[globalX, globalY, rawButtons]=Screen('GetMouseHelper', numMouseButtons);buttons=logical(rawButtons);%renormalize to screen coordinates from display spaceif(nargin==1)    screenRect=Screen('GlobalRect',windowPtrOrScreenNumber);    x=globalX-screenRect(RectLeft);    y=globalY-screenRect(RectTop);else    x=globalX;    y=globalY;end% -------------------------------------------------------------------------function [angle, radius] = GetPolarCoordinates(h,v,centerH,centerV)% George Alvarez: alvarez@mit.edu% Version: 1.0% Last Modified: 09.29.2005% [angle, radius] = GetPolarCoordinates(1,1,250,250)% ********** Input Variables% h = current horizontal position% v = current vertical position% centerH = horizontal center position% centerv = vertical center position% **********% ********** Return Values% angle     = angular position in degrees% radius    = radius in pixels% **********% ********** Purpose (what this function does)% given a horizontal and vertical position,% determine polar coordinates with respect to some center point% **********% ********** Outline% This function is broken down into 2 main steps% 1. Get Polar Coordinates% **********% 1. Get Polar Coordinateshdist   = h-centerH;vdist   = v-centerV;hyp     = sqrt(hdist.*hdist + vdist.*vdist)+(.000000000000000000000000000000000000000000000000001);% determine angle using cosine (hyp will never be zero)tempAngle = acos(hdist./hyp)./pi*180;% correct angle depending on quadranttempAngle(find(hdist == 0 & vdist > 0)) = 90;tempAngle(find(hdist == 0 & vdist < 0)) = 270;tempAngle(find(vdist == 0 & hdist > 0)) = 0;tempAngle(find(vdist == 0 & hdist < 0)) = 180;tempAngle(find(hdist < 0 & vdist < 0))=360-tempAngle(find(hdist < 0 & vdist < 0));tempAngle(find(hdist > 0 & vdist < 0))=360-tempAngle(find(hdist > 0 & vdist < 0));angle   = tempAngle;radius  = hyp;% -------------------------------------------------------------------------function [h, v, valid] = GetIntersection(L1H1, L1V1, L1H2, L1V2, L2H1, L2V1, L2H2, L2V2)% function [value] = MatlabTemplate(input)% George Alvarez: alvarez@mit.edu% Version: 1.0% Last Modified: 10.12.2005% demo: [h, v, valid] = GetIntersection(0, 0, 100, 100, 0, 100, 100, 0)% ********** Input Variables% L1H1: line one, horizontal position (of point 1)% L1V1: line one, vertical position (of point 1)% L1H2: line one, horizontal position (of point 2)% L1V2: line one, vertical position (of point 2)% L2H1: line two, horizontal position (of point 1)% L2V1: line two, vertical position (of point 1)% L2H2: line two, horizontal position (of point 2)% L2V2: line two, vertical position (of point 2)% **********% ********** Return Values% h: horizontal position of intersection point% v: vertical position of intersection point% valid: whether the intersection is real for these segments, or outside off of these segments% **********% ********** Purpose (what this function does)% To get the intersection point for two segments defined each by two points%% **********% ********** Outline% This function is broken down into 2 main steps% 1. initialize some variables% 2. compute the intersection% 3. check whether this is a valid intersection point% **********% 1. Initialize Some Variables ********************************************b1 = (L1V1-L1V2)./((L1H1-L1H2)+.0000000000000000000000000000000000000000000001); % slope of line 1b2 = (L2V1-L2V2)./((L2H1-L2H2)+.0000000000000000000000000000000000000000000001); % slope of line 2a1 = L1V1 - b1 .* L1H1; % intercept of line 1a2 = L2V1 - b2 .* L2H1; % intercept of line 1% *************************************************************************% 2. Compute Intersection *************************************************% magic...h = -(a1 - a2)./((b1 - b2)+.0000000000000000000000000000000000000000000001);v = a1 + b1 .* h;% *************************************************************************% 3. Check Validity *******************************************************% the logic here is that if the intersection point is less (or more) than% both endpoints of either line (either in the horizontal or vertical% direction), then the point is not on the line segments (it is off in the% distance somwhere).valid(1:length(h))=1;valid(find( ((h < L1H1) & (h < L1H2)) | ((h > L1H1) & (h > L1H2)) ))=0;valid(find( ((h < L2H1) & (h < L2H2)) | ((h > L2H1) & (h > L2H2)) ))=0;valid(find( ((v < L1V1) & (v < L1V2)) | ((v > L1V1) & (v > L1V2)) ))=0;valid(find( ((v < L2V1) & (v < L2V2)) | ((v > L2V1) & (v > L2V2)) ))=0;% *************************************************************************% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function GetKeyboard()% purpose: figure out which keyboard experimenter is usingglobal drawWin win1 bcolor screenRect activeRectglobal whichKeyboard TextFontSize% find out which devices are keyboardsdevices=PsychHID('Devices');keyboard=[];for dev=1:length(devices)    if streq('Keyboard',devices(dev).usageName)        keyboard=[keyboard dev];    endend% prompt experimenter to press a keyFillRect(drawWin,bcolor,screenRect);TextSize(drawWin,TextFontSize);textStr = 'PRESS ANY KEY TO BEGIN EXPERIMENT';[textX, textY] = CenterText(drawWin,screenRect,textStr,36);DrawText(drawWin, textStr, textX, textY, [0 0 0]);tempTexture=MakeTexture(drawWin, activeRect);ShowScreen(drawWin, activeRect);TextureClose(tempTexture);    % then figure out which keyboard the experimenter is usingcount=0;keydata=[];while ~any(keydata)        % select keyboard to test    count=count+1;    if (count > length(keyboard))        count=1;    end    whichKeyboard=keyboard(count);        % test this keyboard    [keyIsDown,secs,keyCode]=KbCheck([whichKeyboard]);    if keyIsDown        keydata=find(keyCode);        keydata=keydata(1);    endend% -------------------------------------------------------------------------% -------------------------------------------------------------------------function GetKeys()% purpose: get keys for subject responsesglobal fid filename expname sinit condnum condname numItems redgreen yesno currTrial currBlock numBlocks numTrialsPerBlock currType randomsequence numtypesglobal condnumArray condnameArray setsizeArray whichoneArray redgreenArray yesnoArray responseArray RTArray errorArrayglobal drawWin win1 stimulusWin blankWin tempWin endWin tempTexture endTexture screenX screenY centerX centerY screenRect activeRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal responseModeglobal whichKeyboard TextFontSizeif (responseMode==1)    Key1=kbname('a');    Key2=kbname('''');    QuitKey=kbname('q');else    Key1=99;    Key2=99;    QuitKey=kbname('q');        while (Key1==Key2)        FillRect(drawWin,bcolor,screenRect);        TextSize(drawWin,TextFontSize);        if (responseMode == 2)            textStr = 'PRESS A KEY FOR RED';        else            textStr = 'PRESS A KEY FOR TARGET';        end        [textX, textY] = CenterText(drawWin,screenRect,textStr,36);        DrawText(drawWin, textStr, textX, textY, [0 0 0]);        tempTexture=MakeTexture(drawWin, activeRect);        ShowScreen(drawWin, activeRect);        TextureClose(tempTexture);        while(1)            [keyIsDown,secs,keyCode]=KbCheck([whichKeyboard]);            if keyIsDown                Key1=find(keyCode);                Key1=Key1(1);                break;            end        end        ClearKeys;        ShowScreen(blankWin, activeRect);        WaitSecs(1);        FillRect(drawWin,bcolor,screenRect);        TextSize(drawWin,TextFontSize);        if (responseMode == 2)            textStr = 'PRESS A KEY FOR GREEN';        else            textStr = 'PRESS A KEY FOR DISTRACTOR';        end        [textX, textY] = CenterText(drawWin,screenRect,textStr,36);        DrawText(drawWin, textStr, textX, textY, [0 0 0]);        tempTexture=MakeTexture(drawWin, activeRect);        ShowScreen(drawWin, activeRect);        TextureClose(tempTexture);        while(1)            [keyIsDown,secs,keyCode]=KbCheck([whichKeyboard]);            if keyIsDown                Key2=find(keyCode);                Key2=Key2(1);                break;            end        end        ClearKeys;        ShowScreen(blankWin, activeRect);        WaitSecs(1);    endend% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function SetupCoordinates(preview)global LEFT RIGHT TOP BOTTOMglobal fid filename expname sinit condnum condname numItems redgreen yesno currTrial currBlock numBlocks numTrialsPerBlock currType randomsequence numtypesglobal condnumArray condnameArray setsizeArray whichoneArray redgreenArray yesnoArray responseArray RTArray errorArrayglobal win1 stimulusWin tempWin screenX screenY centerX centerY screenRect activeRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTexture tempTexture FixSize ShowFramesglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal QUADSIZE INSET LLEFT LRIGHT LTOP LBOTTOM RLEFT RRIGHT RTOP RBOTTOM LRECT RRECT AREARECTif (LAYOUT == 1)		%coordinates are defined by a grid    %determine cell size    CELL_WIDTH 	= (HORIZONTAL_EXTENT - ((HORIZONTAL_POSITIONS-1)*SPACING))/HORIZONTAL_POSITIONS;    %width of each cell in the grid (decreases as the size of the space between cells increases)    CELL_HEIGHT	= (VERTICAL_EXTENT   - ((VERTICAL_POSITIONS  -1)*SPACING))/VERTICAL_POSITIONS;      %height of each cell in the grid (decreases as the size of the space between cells increases)    X_SPACE     = HORIZONTAL_EXTENT/HORIZONTAL_POSITIONS;                                           % horizontal center to center spacing between cells    Y_SPACE     = VERTICAL_EXTENT/VERTICAL_POSITIONS;                                               % vertical center to center spacing between cells    %define the evenly spaced grid coordinates    count           = 1;    NUM_POSITIONS   = 0;    for i=1:VERTICAL_POSITIONS        for j=1:HORIZONTAL_POSITIONS            if (RESERVE_FIXATION == 1 & mod(HORIZONTAL_POSITIONS,2) == 1 & mod(VERTICAL_POSITIONS,2) == 1 & count==median(1:HORIZONTAL_POSITIONS*VERTICAL_POSITIONS)) %skip the middle location if reserved                count = count + 1;            else                NUM_POSITIONS = NUM_POSITIONS + 1;                MASTER_COORDINATES_h(NUM_POSITIONS) = centerX - ((HORIZONTAL_POSITIONS-1)/2) * X_SPACE + (j-1) * X_SPACE;                MASTER_COORDINATES_v(NUM_POSITIONS) = centerY - ((VERTICAL_POSITIONS-1)/2) * Y_SPACE + (i-1) * Y_SPACE;                count = count + 1;                % based on the room within the cell available for jitter, set jitter size in each direction                Y_JITTER =  max(0,(CELL_HEIGHT - Y_SIZE)/2);    % jitter can't be less than zero, equals cellsize minus item size, divided by two                X_JITTER =  max(0,(CELL_WIDTH - X_SIZE)/2);     % jitter can't be less than zero, equals cellsize minus item size, divided by two            end        end    endelseif (LAYOUT == 2)	% a circular array    for i=1:NUM_POSITIONS        MASTER_COORDINATES_h(i) = centerX + RADIUS * cos(2*pi/NUM_POSITIONS * (i-1) - pi/2);        MASTER_COORDINATES_v(i) = centerY + RADIUS * sin(2*pi/NUM_POSITIONS * (i-1) - pi/2);    endelseif (LAYOUT == 3)	% define some locations by brut force    % at fixation    MASTER_COORDINATES_h(1) = centerX;    MASTER_COORDINATES_v(1) = centerY;    % left of fixation    MASTER_COORDINATES_h(2) = centerX - 150;    MASTER_COORDINATES_v(2) = centerY;    % right of fixation    MASTER_COORDINATES_h(3) = centerX + 150;    MASTER_COORDINATES_v(3) = centerY;    NUM_POSITIONS=length(MASTER_COORDINATES_h);elseif (LAYOUT == 4)    % divide display into quadrants    % setup    QuadWidth	= QUADSIZE;                  % width of a quadrant    QuadHeight	= QUADSIZE;                    % height of a quadrant    CELL_WIDTH 	= (QuadWidth)/(HORIZONTAL_POSITIONS);     % the width of a cell within the quadrant    CELL_HEIGHT	= (QuadHeight)/(VERTICAL_POSITIONS);      % the height of a cell within the quadrant    count		= 1;    % LEFT    QuadCenterX	= LLEFT + (LRIGHT-LLEFT)/2;    QuadCenterY	= centerY;        for v=1:VERTICAL_POSITIONS        for h=1:HORIZONTAL_POSITIONS            MASTER_COORDINATES_h(count) = QuadCenterX - ((HORIZONTAL_POSITIONS-1)/2) * CELL_WIDTH + (h-1) * CELL_WIDTH;            MASTER_COORDINATES_v(count) = QuadCenterY - ((VERTICAL_POSITIONS-1)/2) * CELL_HEIGHT + (v-1) * CELL_HEIGHT;            count = count+1;        end    end    % RIGHT QUADRANT    QuadCenterX	= RLEFT + (RRIGHT-RLEFT)/2;    QuadCenterY	= centerY;    for v=1:VERTICAL_POSITIONS        for h=1:HORIZONTAL_POSITIONS            MASTER_COORDINATES_h(count) = QuadCenterX - ((HORIZONTAL_POSITIONS-1)/2) * CELL_WIDTH + (h-1) * CELL_WIDTH;            MASTER_COORDINATES_v(count) = QuadCenterY - ((VERTICAL_POSITIONS-1)/2) * CELL_HEIGHT + (v-1) * CELL_HEIGHT;            count = count+1;        end    end    NUM_POSITIONS=length(MASTER_COORDINATES_h);elseif (LAYOUT == 5)    % setup    number 		= HEMI_NUM_PER_RING*4+4;    % this excludes the horizontal and vertical midlines from the circular array    tempRadius 	= RADIUS;    % get locations    count 		= 1;    for i=1:HEMI_NUM_RINGS        for j=1:number            if ( mod(j,(HEMI_NUM_PER_RING+1)) ~= 0)                MASTER_COORDINATES_h(count) = centerX + tempRadius * cos(2*pi/number * (j-1) - pi/2 + (2*pi/number));                MASTER_COORDINATES_v(count) = centerY + tempRadius * sin(2*pi/number * (j-1) - pi/2 + (2*pi/number));                count = count + 1;            end        end        %take the distance between two adjacent disks on the current ring        hdist=MASTER_COORDINATES_h(count-1) - MASTER_COORDINATES_h(count-2);        vdist=MASTER_COORDINATES_v(count-1) - MASTER_COORDINATES_v(count-2);        %then add twice this distance to the current radius so that the        %distance between items on one ring is half the distance between        %items on different rings (but equivalent in terms of crowding, Intiligator and Cavanagh)        tempdistance = sqrt (hdist*hdist+vdist*vdist);        tempRadius = tempRadius + 2*tempdistance;    end    NUM_POSITIONS=length(MASTER_COORDINATES_h);end% make sure the coordinates are integersMASTER_COORDINATES_h=round(MASTER_COORDINATES_h);MASTER_COORDINATES_v=round(MASTER_COORDINATES_v);if (preview)    % draw an outline of the display    %blank screen with fixation point    FillRect(tempWin, bcolor, screenRect);    FillOval(tempWin, [0 0 0], [centerX-FixSize centerY-FixSize centerX+FixSize centerY+FixSize]);    if (ShowFrames)        FrameRect(tempWin,[0 0 0],LRECT);        FrameRect(tempWin,[0 0 0],RRECT);        FrameRect(tempWin,[0 0 0],AREARECT);    end        %draw grid cells    if (LAYOUT == 1)        for i=1:NUM_POSITIONS            FillRect(tempWin,[0 0 0],[MASTER_COORDINATES_h(i)-CELL_WIDTH/2 MASTER_COORDINATES_v(i)-CELL_HEIGHT/2 MASTER_COORDINATES_h(i)+CELL_WIDTH/2 MASTER_COORDINATES_v(i)+CELL_HEIGHT/2]);            %Screen('FillRect', tempWin, [0 0 0], [MASTER_COORDINATES_h(i)-CELL_WIDTH/2 MASTER_COORDINATES_v(i)-CELL_HEIGHT/2 MASTER_COORDINATES_h(i)+CELL_WIDTH/2 MASTER_COORDINATES_v(i)+CELL_HEIGHT/2]);        end    else        CELL_WIDTH=X_SIZE;        CELL_HEIGHT=Y_SIZE;        for i=1:NUM_POSITIONS            FillRect(tempWin,[0 0 0],[MASTER_COORDINATES_h(i)-CELL_WIDTH/2 MASTER_COORDINATES_v(i)-CELL_HEIGHT/2 MASTER_COORDINATES_h(i)+CELL_WIDTH/2 MASTER_COORDINATES_v(i)+CELL_HEIGHT/2]);            %Screen('FillRect', tempWin, [0 0 0], [MASTER_COORDINATES_h(i)-CELL_WIDTH/2 MASTER_COORDINATES_v(i)-CELL_HEIGHT/2 MASTER_COORDINATES_h(i)+CELL_WIDTH/2 MASTER_COORDINATES_v(i)+CELL_HEIGHT/2]);        end    end    tempTexture=MakeTexture(tempWin, activeRect);    ShowScreen(tempWin, [centerX-max(HORIZONTAL_EXTENT/2,VERTICAL_POSITIONS/2) centerY-max(HORIZONTAL_EXTENT/2,VERTICAL_POSITIONS/2) centerX+max(HORIZONTAL_EXTENT/2,VERTICAL_POSITIONS/2) centerY+max(HORIZONTAL_EXTENT/2,VERTICAL_POSITIONS/2)]);    TextureClose(tempTexture);    WaitSecs(1);endMASTER_COORDINATES_h;MASTER_COORDINATES_v;leftCount=0;rightCount=0;for i=1:NUM_POSITIONS    if (MASTER_COORDINATES_h(i) < centerX)        leftCount=leftCount+1;        LEFT_COORDINATES_h(leftCount)=MASTER_COORDINATES_h(i);        LEFT_COORDINATES_v(leftCount)=MASTER_COORDINATES_v(i);    else        rightCount=rightCount+1;        RIGHT_COORDINATES_h(rightCount)=MASTER_COORDINATES_h(i);        RIGHT_COORDINATES_v(rightCount)=MASTER_COORDINATES_v(i);    end   end    % -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function LoadImageFiles(color)global win1 screenRect bcolorglobal jpgFiles numImages imageArrayglobal imageDir TextFontSize% this function reads in image files% for black and white, color = 0, for color, color = 1cd(imageDir);                           % change to image file directoryjpgFiles = dir('*.jpg');                % get jpg file namesnumImages = size(jpgFiles,1);           % number of image files% load themif (numImages > 0)    for i=1:numImages        imageArray{i}   = double(imread(jpgFiles(i).name));     % read in image        if (color == 0) % black and white            imageArray{i} = mean(imageArray{i},3);              % average r, g, b, if image is in color        end        % inform experimenter of what is going on        FillRect(win1,bcolor,screenRect);        TextSize(win1,TextFontSize);        textStr = ['LOADING FILE #' num2str(i) ' OUT OF ' num2str(numImages)];        [textX, textY] = CenterText(win1,screenRect,textStr,36);        DrawText(win1, textStr, textX, textY, [0 0 0]);        ShowScreen(win1, screenRect);    endend% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function InitBlock(waitForKeypress)global fid filename expname sinit condnum condname numItems redgreen yesno currTrial currBlock numBlocks numTrials numTrialsPerBlock currType randomsequence numtypesglobal condnumArray condnameArray setsizeArray whichoneArray redgreenArray yesnoArray responseArray RTArray errorArrayglobal win1 tempWin blankWin fixWin stimulusWin drawWin screenX screenY centerX centerY screenRect activeRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTexture tempTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal whichKeyboard TextFontSizeglobal runMode% 1. randomized trial orderif (runMode==1)         % when running from files, just randomize order for entire experiment (on the first block)    if (currBlock==1)        randomsequence  = randperm(numTrials);    endelse                    % when running online, randomize order for each block    randomsequence  = randperm(numTrials);endif (waitForKeypress == 1)        % 2. init block message    FillRect(drawWin,bcolor,screenRect);    TextSize(drawWin,TextFontSize);    textStr = ['PRESS ANY KEY TO BEGIN BLOCK #' num2str(currBlock) ' of ' num2str(numBlocks)];    [textX, textY] = CenterText(drawWin,screenRect,textStr,36);    DrawText(drawWin, textStr, textX, textY, [0 0 0]);    tempTexture=MakeTexture(drawWin, activeRect);    ShowScreen(drawWin, activeRect);    TextureClose(tempTexture);    %WaitSecs(1);    % mandatory 3 seconds waiting    % 3. Get Key Press    % make sure no key is currently pressed    [keyIsDown,secs,keyCode]=KbCheck([whichKeyboard]);    while(keyIsDown)        [keyIsDown,secs,keyCode]=KbCheck([whichKeyboard]);    end    % wait for keypress    while(1)        [keyIsDown,secs,keyCode]=KbCheck([whichKeyboard]);        if keyIsDown            break;        end    end    ClearKeys;    % show a blank screen    ShowScreen(blankWin, [centerX-centerY centerY-centerY centerX+centerY centerY+centerY]);end% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function InitTrial(waitForKeypress, whichTrial)global fid filename expname sinit condnum condname numItems redgreen yesno currTrial currBlock numBlocks numTrialsPerBlock currType randomsequence numtypesglobal condnumArray condnameArray setsizeArray whichoneArray redgreenArray yesnoArray responseArray RTArray errorArrayglobal win1 tempWin blankWin fixWin stimulusWin trialWin drawWin screenX screenY centerX centerY screenRect activeRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTexture tempTexture trialTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal whichKeyboard TextFontSizecurrTrial=currTrial+1;if (waitForKeypress == 1)    % init block message    FillRect(drawWin,bcolor,screenRect);    TextSize(drawWin,TextFontSize);    textStr = ['PRESS ANY KEY TO BEGIN TRIAL #' num2str(whichTrial) ' of ' num2str(numTrialsPerBlock)];    [textX, textY] = CenterText(drawWin,screenRect,textStr,36);    DrawText(drawWin, textStr, textX, textY, [0 0 0]);    tempTexture=MakeTexture(drawWin, activeRect);    ShowScreen(drawWin, activeRect);    TextureClose(tempTexture);    % make sure no key is currently pressed    [keyIsDown,secs,keyCode]=KbCheck([whichKeyboard]);    while(keyIsDown)        [keyIsDown,secs,keyCode]=KbCheck([whichKeyboard]);    end    % then check for keypress    while(1)        [keyIsDown,secs,keyCode]=KbCheck([whichKeyboard]);        if keyIsDown            break;        end    end    ClearKeys;    % show a blank screen    ShowScreen(blankWin, [centerX-centerY centerY-centerY centerX+centerY centerY+centerY]);    WaitSecs(1);end% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function GetTrialType(whichTrial)global fid filename expname sinit condnum condname numItems redgreen yesno probefield currTrial currBlock numBlocks numTrialsPerBlock currType randomsequence numtypesglobal condnumArray condnameArray setsizeArray whichoneArray redgreenArray yesnoArray responseArray RTArray errorArrayglobal win1 stimulusWin screenX screenY centerX centerY screenRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal numTargets;global TWOTARGETSPEED FOURTARGETSPEED ITEMSPEEDcurrType = mod(randomsequence(whichTrial),4)+1;if      (currType == 1)   condnum = 4; condname='TwoLeft';          numTargets=2; redgreen = randInt(1,2); yesno = randInt(0,1); probefield=1;elseif  (currType == 2)   condnum = 5; condname='TwoRight';         numTargets=2; redgreen = randInt(1,2); yesno = randInt(0,1); probefield=2;elseif  (currType == 3)   condnum = 7; condname='FourBilateral';    numTargets=4; redgreen = randInt(1,2); yesno = randInt(0,1); probefield=1;elseif  (currType == 4)   condnum = 7; condname='FourBilateral';    numTargets=4; redgreen = randInt(1,2); yesno = randInt(0,1); probefield=2;endif (numTargets == 2)    ITEMSPEED = TWOTARGETSPEEDelse    ITEMSPEED = FOURTARGETSPEEDendnumItems    = 8;% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************function PrepareTrial()global runModeglobal trajFileNameif (runMode == 1)           % running from precomputed files    GetItemID;              % sets item size, speed, color, shape & which is a target, etc.    LoadTrial;              % loads trajectories, and OVERWRITES target ID and which item is probed (to overwrite other values, must store them when saving)else                        % running "online" or computing trajectory files        trajFileName='online';  % not running from files    GetItemPositions;       % computing current item positions "online"    GetItemID;              % sets item size, speed, color, shape & which is a target, etc.end% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function GetItemPositions()global fid filename expname sinit condnum condname numItems redgreen yesno currTrial currBlock numBlocks numTrialsPerBlock currType randomsequence numtypesglobal condnumArray condnameArray setsizeArray whichoneArray redgreenArray yesnoArray responseArray RTArray errorArrayglobal win1 stimulusWin screenX screenY centerX centerY screenRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal itemCoordinates_h itemCoordinates_v itemGoalPos itemGoalH itemGoalV itemDirection itemSpeed itemSize itemColor itemShape itemIsTarget itemIsProbeglobal itemColor itemCorrectColor itemIncorrectColor itemBlankColor global itemLeft itemRight itemTop itemBottomglobal LEFT RIGHT TOP BOTTOMglobal QUADSIZE INSET LLEFT LRIGHT LTOP LBOTTOM RLEFT RRIGHT RTOP RBOTTOM LRECT RRECT AREARECTCoordinates_h = 0;Coordinates_v = 0;randLeftLocations=randperm(NUM_POSITIONS/2);                                % array with all possible positions in random orderfor i=1:numItems/2    Coordinates_h(i)=LEFT_COORDINATES_h(randLeftLocations(i));              % h coordinates based on random set of master coordinates    Coordinates_v(i)=LEFT_COORDINATES_v(randLeftLocations(i));             % v coordinates based on random set of master coordinatesendrandRightLocations=randperm(NUM_POSITIONS/2);                               % array with all possible positions in random ordercount=numItems/2;for i=1:numItems/2    count=count+1;    Coordinates_h(count)=RIGHT_COORDINATES_h(randRightLocations(i));              % h coordinates based on random set of master coordinates    Coordinates_v(count)=RIGHT_COORDINATES_v(randRightLocations(i));             % v coordinates based on random set of master coordinatesendfor i=1:numItems    itemCoordinates_h(i)=Coordinates_h(i);    itemCoordinates_v(i)=Coordinates_v(i);end% get edges    inset=64;for i=1:numItems    if (i<=numItems/2)        itemLeft(i)     = LEFT - inset;        itemRight(i)    = centerX - inset;        itemTop(i)      = TOP;        itemBottom(i)   = BOTTOM;        itemLeft(i)     = LLEFT;        itemRight(i)    = LRIGHT;        itemTop(i)      = LTOP;        itemBottom(i)   = LBOTTOM;            else        itemLeft(i)     = centerX + inset;        itemRight(i)    = RIGHT + inset;        itemTop(i)      = TOP;        itemBottom(i)   = BOTTOM;        itemLeft(i)     = RLEFT;        itemRight(i)    = RRIGHT;        itemTop(i)      = RTOP;        itemBottom(i)   = RBOTTOM;            end        %itemLeft(i)     = LEFT;    %itemRight(i)    = RIGHT;    %itemTop(i)      = TOP;    %itemBottom(i)   = BOTTOM;end% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function GetItemID()global fid filename expname sinit condnum condname numItems redgreen yesno probefield currTrial currBlock numBlocks numTrialsPerBlock currType randomsequence numtypesglobal condnumArray condnameArray setsizeArray whichoneArray redgreenArray yesnoArray responseArray RTArray errorArrayglobal win1 stimulusWin screenX screenY centerX centerY screenRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal itemCoordinates_h itemCoordinates_v itemGoalPos itemGoalH itemGoalV itemDirection itemSpeed itemSize itemColor itemShape itemIsTarget itemIsProbeglobal numTargetsglobal LEFT RIGHT TOP BOTTOMglobal ITEMSIZE ITEMSPEEDglobal itemColor itemCorrectColor itemIncorrectColor itemBlankColor% initialze all variableswhichone                     = 0;itemIsTarget(1:numItems)     = 0;itemOrientation(1:numItems)  = 0;itemSize(1:numItems)         = 0;itemShape(1:numItems)        = 0;itemIsTarget(1:numItems)     = 0;itemIsProbe(1:numItems)      = 0;% item appearancefor i=1:numItems    % item shape    itemShape(i)=0;    % item sizes    itemSize(i)=ITEMSIZE;    % item color    itemColor(1:3,i)=[0; 0; 0];    itemCorrectColor(1:3,i)=[0; 255; 0];    itemIncorrectColor(1:3,i)=[255; 0; 0];    itemBlankColor(1:3,i)=bcolor';        % item direction    itemDirection(i) = randInt(1,360);    % item speed    itemSpeed(i) = ITEMSPEED * 32/60; % 6 degrees per second assuming 32 pixels per degree and a 60 Hz refresh rate    itemOrientation(i)=randInt(1,2);end% get targets and distractorsif (condnum==2) % one left    itemIsTarget(1)=1;    elseif (condnum==3) % one right    itemIsTarget(numItems/2+1)=1;    elseif (condnum==4) % two left    itemIsTarget(1)=1;    itemIsTarget(2)=1;    elseif (condnum==5) % two right    itemIsTarget(numItems/2+1)=1;    itemIsTarget(numItems/2+2)=1;    elseif (condnum==6) % two bilateral    itemIsTarget(1)=1;    itemIsTarget(numItems/2+1)=1;    elseif (condnum==7) % four bilateral    itemIsTarget(1)=1;    itemIsTarget(2)=1;        itemIsTarget(numItems/2+1)=1;    itemIsTarget(numItems/2+2)=1;    end   % get item goal positionsrandomLPositions = randperm(NUM_POSITIONS/2);randomRPositions = randperm(NUM_POSITIONS/2)+(NUM_POSITIONS/2);lcount=0;rcount=0;for i=1:numItems    if (i<=numItems/2)        lcount=lcount+1;        itemGoalPos(i) = randomLPositions(lcount);    else        rcount=rcount+1;        itemGoalPos(i) = randomRPositions(rcount);    endend% which items to probeif (sum(itemIsTarget)>=1) % if there is at least 1 target    while (1)        if (probefield == 1)      % left test            which = randInt(1,numItems/2);            if (itemIsTarget(which)==1 & itemIsProbe(which) == 0) % find a distractor that isn't already a probe                itemIsProbe(which)=1;                break;            end        elseif (probefield == 2)  % right test            which = randInt(numItems/2+1,numItems);            if (itemIsTarget(which)==1 & itemIsProbe(which) == 0) % find a distractor that isn't already a probe                itemIsProbe(which)=1;                break;            end        end    endelse    which = randInt(1,numItems);    itemIsProbe(which)=1;end% choose a distractorif (sum(itemIsTarget)>=1) % if there is at least 1 target, highlight a distractor    while (1)        if (probefield == 1)      % left test            which = randInt(1,numItems/2);            if (itemIsTarget(which)==0 & itemIsProbe(which) == 0) % find a distractor that isn't already a probe                itemIsProbe(which)=1;                break;            end        elseif (probefield == 2)  % right test            which = randInt(numItems/2+1,numItems);            if (itemIsTarget(which)==0 & itemIsProbe(which) == 0) % find a distractor that isn't already a probe                itemIsProbe(which)=1;                break;            end        end    endend% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function DrawStimuli()global fid filename expname sinit condnum condname numItems redgreen yesno currTrial currBlock numBlocks numTrialsPerBlock currType randomsequence numtypesglobal condnumArray condnameArray setsizeArray whichoneArray redgreenArray yesnoArray responseArray RTArray errorArrayglobal win1 stimulusWin screenX screenY centerX centerY screenRect activeRect drawWinglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTexture tempTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal DrawTimet1=GetSecs;% StimulusWin(1)...%blank screen with fixation pointFillRect(stimulusWin(1),bcolor,screenRect);FillRect(stimulusWin(1),[0 0 0],[centerX-20 centerY-5 centerX+20 centerY+5]);FillRect(stimulusWin(1),[0 0 0],[centerX-5 centerY-20 centerX+5 centerY+20]);%draw itemsfor i=1:numItems    if (itemIsTarget(i)==1)        drawT(i,stimulusWin(1),itemColor(i));    else        drawL(i,stimulusWin(1),itemColor(i));    endend%make into a texturetempTexture=MakeTexture(stimulusWin(1), activeRect);% StimulusWin(2)...%blank screen with fixation point%draw items%make into a textureDrawTime = GetSecs-t1;% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function ComputeFrame(whichFrame)global runMode itemColor itemIsTarget numItems% 1. Get Current Item Locationsif (runMode == 1)    LoadItemPositions(whichFrame);      % from fileselse    ComputeRepulsionFast(whichFrame);   % compute "online"end% 2. update item identities (e.g., blinking targets or highlighting item for test)% highlight target items%if (whichFrame <= 60)%   for i=1:numItems%        if (itemIsTarget(i))%            itemColor(i,1:3)=[255 0 0]; % make targets red%        end%    end%else%    for i=1:numItems%        itemColor(i,1:3)=[0 0 0]; % make targets red%    end%end% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function ComputeRepulsionSlow(whichFrame)global LEFT RIGHT TOP BOTTOM NUM_POSITIONS MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_vglobal itemCoordinates_h itemCoordinates_v itemGoalPos itemGoalH itemGoalV itemDirection itemSpeed itemSize itemColor itemShape itemIsTarget itemIsProbeglobal numItems centerX centerYglobal runMode makeMovie saveTrajectories FILE_TRAJECTORIES% 1. Buffers (minium spacing - used to determine 'bounces') & Display SizeitemBuffer  = 60;            % minimum spacing between items (center to center)edgeBuffer  = 10;            % between item and edge (center of item)fixBuffer   = 60;            % between item and fixation (center to center)trajBuffer  = 60;            % between item and intersection of trajectoriesgoalBuffer  = 80;            % distance from goal when a new goal position is determinedmaxHDist    = RIGHT-LEFT;    % maximum horizontal distancemaxVDist    = BOTTOM-TOP;    % maximum vertical distancemaxItemDist = sqrt( maxHDist*maxHDist + maxVDist*maxVDist);maxFixDist  = sqrt( (maxHDist/2)*(maxHDist/2) + (maxVDist/2)*(maxVDist/2));% 2. Distance Scale (dropoff over distance)% used in power function, so .5 = square root.itemScale = 0.10;            % between itemsedgeScale = 0.10;            % item vs. edgesfixScale  = 0.10;            % item vs. fixationgoalScale = 1.35;            % attraction to goal position remains strong over distancetrajScale = 0.05;            % item vs. trajectory of other items% 3. Weights (set to zero to turn off repulsion, or to "fiddle" with repulsion strength)itemWeight  =1.0;   % weight given to "push" from other itemsedgeWeight  =1.0;   % push from edgesfixWeight   =1.0;   % push from fixationtrajWeight  =1.0;   % push from trajectorygoalWeight  =1.0;   % pull toward goal% 4. Compute Repulsion for Each Item% get horizontal and vertical vectorshSpeed=cos((itemDirection./180).*pi) .* itemSpeed;vSpeed=sin((itemDirection./180).*pi) .* itemSpeed;for i=1:numItems        % current item's position    h=itemCoordinates_h(i);    v=itemCoordinates_v(i);    % A. EDGE REPULSION ***************************************************    %    % distance from edges    leftDistance    = h-LEFT;    if (leftDistance < edgeBuffer)      leftDistance    = edgeBuffer; end    rightDistance   = RIGHT-h;    if (rightDistance < edgeBuffer)     rightDistance   = edgeBuffer; end    topDistance     = v-TOP;    if (topDistance < edgeBuffer)       topDistance     = edgeBuffer; end    bottomDistance  = BOTTOM-v;    if (bottomDistance < edgeBuffer)    bottomDistance  = edgeBuffer; end    % scale repulsion based on distance and buffer    leftScaleFactor     =1-power( (leftDistance-edgeBuffer)     /(maxHDist-edgeBuffer),edgeScale);    rightScaleFactor    =1-power( (rightDistance-edgeBuffer)    /(maxHDist-edgeBuffer),edgeScale);    topScaleFactor      =1-power( (topDistance-edgeBuffer)      /(maxVDist-edgeBuffer),edgeScale);    bottomScaleFactor   =1-power( (bottomDistance-edgeBuffer)   /(maxVDist-edgeBuffer),edgeScale);    % repulsion strength    edgeRepulseH = leftScaleFactor*itemSpeed(i)-rightScaleFactor*itemSpeed(i);    edgeRepulseV = topScaleFactor*itemSpeed(i)-bottomScaleFactor*itemSpeed(i);    % B. ITEM REPULSION ***************************************************    itemRepulseH=0;    itemRepulseV=0;    minDist=99999;    for item=1:numItems        if item ~= i            % distances            dh = itemCoordinates_h(item)-h;            dv = itemCoordinates_v(item)-v;            dist = sqrt(dh*dh+dv*dv);            if (dist < itemBuffer) dist=itemBuffer; end            % magnitudes of repulsion            itemScaleFactor  = (1-power((dist-itemBuffer)/(maxItemDist-itemBuffer),itemScale));            [tempDirection, radius] = GetPolarCoordinates(h,v,itemCoordinates_h(item),itemCoordinates_v(item));            itemHScaleFactor = itemScaleFactor * cos(tempDirection/180*pi);            itemVScaleFactor = itemScaleFactor * sin(tempDirection/180*pi);            %if (dist < minDist)            %    itemRepulseH = itemHScaleFactor*itemSpeed(i);            %    itemRepulseV = itemVScaleFactor*itemSpeed(i);            %    minDist=dist;            %end            itemRepulseH = itemRepulseH + itemHScaleFactor*itemSpeed(i);            itemRepulseV = itemRepulseV + itemVScaleFactor*itemSpeed(i);        end    end    % C. TRAJECTORY REPULSION *********************************************    trajRepulseH=0;    trajRepulseV=0;    minDist=99999;    for item=1:numItems        if item ~= i            % intersection point            L1H1 = h;            L1V1 = v;            L1H2 = h + itemSpeed(i)*cos(itemDirection(i)/180*pi);            L1V2 = v + itemSpeed(i)*sin(itemDirection(i)/180*pi);            L2H1 = itemCoordinates_h(item);            L2V1 = itemCoordinates_v(item);            L2H2 = itemCoordinates_h(item) + itemSpeed(item)*cos(itemDirection(item)/180*pi);            L2V2 = itemCoordinates_v(item) + itemSpeed(item)*sin(itemDirection(item)/180*pi);            [intH, intV, valid] = GetIntersection(L1H1, L1V1, L1H2, L1V2, L2H1, L2V1, L2H2, L2V2);            % distances            dh = itemCoordinates_h(item)-h;            dv = itemCoordinates_v(item)-v;            dist = sqrt(dh*dh+dv*dv);            if (dist < itemBuffer) dist=itemBuffer; end            % magnitudes of repulsion            trajScaleFactor  = (1-power((dist-itemBuffer)/(maxItemDist-itemBuffer),trajScale));            [tempDirection, radius] = GetPolarCoordinates(h,v,intH,intV);            trajHScaleFactor = trajScaleFactor * cos(tempDirection/180*pi);            trajVScaleFactor = trajScaleFactor * sin(tempDirection/180*pi);            %if (dist < minDist)            %    trajRepulseH = trajHScaleFactor*itemSpeed(i);            %    trajRepulseV = trajVScaleFactor*itemSpeed(i);            %    minDist=dist;            %end            trajRepulseH = trajRepulseH + trajHScaleFactor*itemSpeed(i);            trajRepulseV = trajRepulseV + trajVScaleFactor*itemSpeed(i);        end    end    % D. FIXATION REPULSION ***********************************************    fixRepulseH=0;    fixRepulseV=0;    % distances    dh = centerX-h;    dv = centerY-v;    dist = sqrt(dh*dh+dv*dv);    if (dist < fixBuffer) dist=fixBuffer; end    % magnitudes of repulsion    fixScaleFactor  = (1-power((dist-fixBuffer)/(maxFixDist-fixBuffer),fixScale));    [tempDirection, radius] = GetPolarCoordinates(h,v,centerX,centerY);    fixHScaleFactor = fixScaleFactor * cos(tempDirection/180*pi);    fixVScaleFactor = fixScaleFactor * sin(tempDirection/180*pi);    fixRepulseH = fixHScaleFactor*itemSpeed(i);    fixRepulseV = fixVScaleFactor*itemSpeed(i);    % E. ITEM GOAL ENDPOINT ***********************************************    % if the item "wants" to go somewhere, the display has less of a    % "buzzing" appearance.    % this is basically an "attraction point"    goalRepulseH=0;    goalRepulseV=0;    % distances    itemGoalH(i) = MASTER_COORDINATES_h(itemGoalPos(i));    itemGoalV(i) = MASTER_COORDINATES_v(itemGoalPos(i));    dh = itemGoalH(i)-h;    dv = itemGoalV(i)-v;    dist = sqrt(dh*dh+dv*dv);    if (dist < goalBuffer)        dist=goalBuffer;        % get a new goal position        testGoalPos=itemGoalPos;    % array with current goal positions        itemGoalPos(i)=randInt(1,NUM_POSITIONS); % random new position        while (find(testGoalPos == itemGoalPos(i))) % while any of the old positions match this new one            itemGoalPos(i)=randInt(1,NUM_POSITIONS);        end    end    % magnitudes of repulsion    goalScaleFactor  = (1-power((dist-goalBuffer)/(maxItemDist-goalBuffer),goalScale));    [tempDirection, radius] = GetPolarCoordinates(itemGoalH(i),itemGoalV(i),h,v);    goalHScaleFactor = goalScaleFactor * cos(tempDirection/180*pi);    goalVScaleFactor = goalScaleFactor * sin(tempDirection/180*pi);    goalRepulseH = goalHScaleFactor*itemSpeed(i);    goalRepulseV = goalVScaleFactor*itemSpeed(i);    % F. CHECK FOR OUT OF BOUNDS ******************************************    % overall repulsion    repulsionH = itemRepulseH*itemWeight + edgeRepulseH*edgeWeight + fixRepulseH*fixWeight + trajRepulseH*trajWeight + goalRepulseH*goalWeight;    repulsionV = itemRepulseV*itemWeight + edgeRepulseV*edgeWeight + fixRepulseV*fixWeight + trajRepulseV*trajWeight + goalRepulseV*goalWeight;    % temporary variables to test new direciton (make sure doesn't take you    % out of bounds)    tempDirH = hSpeed(i)+repulsionH;    tempDirV = vSpeed(i)+repulsionV;    [itemDirection(i), radius] = GetPolarCoordinates(tempDirH,tempDirV,0,0);    % check for out of bounds    tempH = itemCoordinates_h(i) + itemSpeed(i) * cos( (itemDirection(i)/180)*pi);    tempV = itemCoordinates_v(i) + itemSpeed(i) * sin( (itemDirection(i)/180)*pi);    if (tempH < LEFT | tempH > RIGHT)        tempDirH = tempDirH*-1;        [itemDirection(i), radius] = GetPolarCoordinates(tempDirH,tempDirV,0,0);    end    if (tempV < TOP | tempV > BOTTOM)        tempDirV = tempDirV*-1;        [itemDirection(i), radius] = GetPolarCoordinates(tempDirH,tempDirV,0,0);    endend% update item locationitemCoordinates_h=itemCoordinates_h + itemSpeed .* cos( (itemDirection./180) .*pi);itemCoordinates_v=itemCoordinates_v + itemSpeed .* sin( (itemDirection./180) .*pi);% 5. Store Current CoordinatesFILE_TRAJECTORIES(:,:,whichFrame)=[itemCoordinates_h; itemCoordinates_v];% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function ComputeRepulsionFast(whichFrame)global LEFT RIGHT TOP BOTTOM NUM_POSITIONS MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_vglobal itemCoordinates_h itemCoordinates_v itemGoalPos itemGoalH itemGoalV itemDirection itemSpeed itemSize itemColor itemShape itemIsTarget itemIsProbeglobal numItems centerX centerYglobal runMode makeMovie saveTrajectories FILE_TRAJECTORIESglobal itemLeft itemRight itemTop itemBottomglobal QUADSIZE% 1. Buffers (minium spacing - used to determine 'bounces') & Display SizeitemBuffer  = 48;            % minimum spacing between items (center to center)edgeBuffer  = 10;            % between item and edge (center of item)fixBuffer   = 60;            % between item and fixation (center to center)trajBuffer  = 60;            % between item and intersection of trajectoriesgoalBuffer  = 80;            % distance from goal when a new goal position is determinedmaxHDist    = (RIGHT-LEFT)/2;% maximum horizontal distancemaxVDist    = BOTTOM-TOP;    % maximum vertical distancemaxItemDist = sqrt( maxHDist*maxHDist + maxVDist*maxVDist);maxItemDist = sqrt( QUADSIZE*QUADSIZE + QUADSIZE*QUADSIZE);maxFixDist  = sqrt( (maxHDist/2)*(maxHDist/2) + (maxVDist/2)*(maxVDist/2));% 2. Distance Scale (dropoff over distance)itemScale = 0.10;            % between itemsedgeScale = 0.10;            % item vs. edgesfixScale  = 0.10;            % item vs. fixationgoalScale = 0.10;            % attraction to goal position stays strong over distancetrajScale = 0.05;% 3. Weights (set to zero to turn off repulsion, or to "fiddle" with repulsion strength)itemWeight  =1.0;   % weight given to "push" from other itemsedgeWeight  =1.0;   % push from edgesfixWeight   =1.0;   % push from fixationtrajWeight  =1.0;   % push from trajectorygoalWeight  =1.0;   % pull toward goal% 4. Compute Repulsion for Each Item% get horizontal and vertical vectorshSpeed=cos((itemDirection./180).*pi) .* itemSpeed;vSpeed=sin((itemDirection./180).*pi) .* itemSpeed;% current positionsh=itemCoordinates_h;v=itemCoordinates_v;% A. EDGE REPULSION ***************************************************% distance from edgesleftDistance    = h-itemLeft;leftDistance(find(leftDistance<edgeBuffer))=edgeBuffer;     % make sure never smaller than bufferrightDistance   = itemRight-h;rightDistance(find(rightDistance<edgeBuffer))=edgeBuffer;   % make sure never smaller than buffertopDistance     = v-itemTop;topDistance(find(topDistance<edgeBuffer))=edgeBuffer;       % make sure never smaller than bufferbottomDistance  = itemBottom-v;bottomDistance(find(bottomDistance<edgeBuffer))=edgeBuffer; % make sure never smaller than buffer% scale repulsion based on distance and bufferleftScaleFactor     =1-power( (leftDistance-edgeBuffer)     ./(maxHDist-edgeBuffer),edgeScale); % varies from 1 to zerorightScaleFactor    =1-power( (rightDistance-edgeBuffer)    ./(maxHDist-edgeBuffer),edgeScale); % varies from 1 to zerotopScaleFactor      =1-power( (topDistance-edgeBuffer)      ./(maxVDist-edgeBuffer),edgeScale); % varies from 1 to zerobottomScaleFactor   =1-power( (bottomDistance-edgeBuffer)   ./(maxVDist-edgeBuffer),edgeScale); % varies from 1 to zero% repulsion strengthedgeRepulseH = leftScaleFactor.*itemSpeed-rightScaleFactor.*itemSpeed;  % horizontal repulsion is the difference between left and rightedgeRepulseV = topScaleFactor.*itemSpeed-bottomScaleFactor.*itemSpeed;  % vertical repulsion is the difference between top and bottom% B. ITEM REPULSION ***************************************************itemRepulseH=0;itemRepulseV=0;x_rep       = repmat(itemCoordinates_h, length(itemCoordinates_h), 1);y_rep       = repmat(itemCoordinates_v, length(itemCoordinates_v), 1);dist        = sqrt((x_rep-x_rep').^2+(y_rep-y_rep').^2);dist(find(dist == 0))=maxItemDist+itemBuffer*2;dist(find(dist<itemBuffer))=itemBuffer;itemScaleFactor  = (1-power((dist-itemBuffer) ./ (maxItemDist-itemBuffer),itemScale));[tempDirection, radius] = GetPolarCoordinates(x_rep,y_rep,x_rep',y_rep');itemHScaleFactor = itemScaleFactor .* cos(tempDirection./180*pi);itemVScaleFactor = itemScaleFactor .* sin(tempDirection./180*pi);itemRepulseH = sum(itemHScaleFactor).*itemSpeed;itemRepulseV = sum(itemVScaleFactor).*itemSpeed;% C. TRAJECTORY REPULSION *********************************************trajRepulseH=0;trajRepulseV=0;% intersection pointsL1H1 = h;L1V1 = v;L1H2 = h + itemSpeed.*cos(itemDirection./180.*pi);L1V2 = v + itemSpeed.*sin(itemDirection./180.*pi);L1X1_rep       = repmat(L1H1, length(L1H1), 1);L1Y1_rep       = repmat(L1V1, length(L1V1), 1);L1X2_rep       = repmat(L1H2, length(L1H2), 1);L1Y2_rep       = repmat(L1V2, length(L1V2), 1);[intH, intV, valid] = GetIntersection(L1X1_rep, L1Y1_rep, L1X2_rep, L1Y2_rep, L1X1_rep', L1Y1_rep', L1X2_rep', L1Y2_rep');% distancesx_rep       = repmat(itemCoordinates_h, length(itemCoordinates_h), 1);y_rep       = repmat(itemCoordinates_v, length(itemCoordinates_v), 1);dist        = sqrt((x_rep-x_rep').^2+(y_rep-y_rep').^2);dist(find(dist == 0))=maxItemDist+itemBuffer*2;dist(find(dist<itemBuffer))=itemBuffer;% scale factortrajScaleFactor  = (1-power((dist-itemBuffer) ./ (maxItemDist-itemBuffer),trajScale));[tempDirection, radius] = GetPolarCoordinates(x_rep,y_rep,intH,intV);trajHScaleFactor = trajScaleFactor .* cos(tempDirection./180.*pi);trajVScaleFactor = trajScaleFactor .* sin(tempDirection./180.*pi);trajRepulseH = sum(trajHScaleFactor).*itemSpeed;trajRepulseV = sum(trajVScaleFactor).*itemSpeed;% D. FIXATION REPULSION ***********************************************fixRepulseH=0;fixRepulseV=0;% distancesdh = centerX-h;dv = centerY-v;dist = sqrt(dh.*dh+dv.*dv);dist(find(dist<fixBuffer))=fixBuffer;% magnitudes of repulsionfixScaleFactor  = (1-power((dist-fixBuffer) ./ (maxFixDist-fixBuffer),fixScale));[tempDirection, radius] = GetPolarCoordinates(h,v,centerX,centerY);fixHScaleFactor = fixScaleFactor .* cos(tempDirection./180.*pi);fixVScaleFactor = fixScaleFactor .* sin(tempDirection./180.*pi);fixRepulseH = fixHScaleFactor.*itemSpeed;fixRepulseV = fixVScaleFactor.*itemSpeed;% E. ITEM GOAL ENDPOINT ***********************************************% if the item "wants" to go somewhere, the display has less of a% "buzzing" appearance.% this is basically an "attraction point"goalRepulseH=0;goalRepulseV=0;% distancesitemGoalH = MASTER_COORDINATES_h(itemGoalPos);itemGoalV = MASTER_COORDINATES_v(itemGoalPos);dh = itemGoalH-h;dv = itemGoalV-v;dist = sqrt(dh.*dh+dv.*dv);for i=1:numItems    if (dist(i) < goalBuffer)        dist(i)=goalBuffer;        % get a new goal position        testGoalPos=itemGoalPos;                                            % array with current goal positions        if (i <= numItems/2)            itemGoalPos(i)=randInt(1,NUM_POSITIONS/2);                      % random new position            while (find(testGoalPos == itemGoalPos(i)))                     % while any of the old positions match this new one                itemGoalPos(i)=randInt(1,NUM_POSITIONS/2);            end        else            itemGoalPos(i)=randInt((NUM_POSITIONS/2+1),NUM_POSITIONS);      % random new position            while (find(testGoalPos == itemGoalPos(i)))                     % while any of the old positions match this new one                itemGoalPos(i)=randInt((NUM_POSITIONS/2+1),NUM_POSITIONS);            end        end            endend% magnitudes of repulsiongoalScaleFactor  = (1-power((dist-goalBuffer)./(maxItemDist-goalBuffer),goalScale));[tempDirection, radius] = GetPolarCoordinates(itemGoalH,itemGoalV,h,v);goalHScaleFactor = goalScaleFactor .* cos(tempDirection./180.*pi);goalVScaleFactor = goalScaleFactor .* sin(tempDirection./180.*pi);goalRepulseH = goalHScaleFactor .* itemSpeed;goalRepulseV = goalVScaleFactor .* itemSpeed;% F. CHECK FOR OUT OF BOUNDS ******************************************% overall repulsionrepulsionH = itemRepulseH*itemWeight + edgeRepulseH*edgeWeight + fixRepulseH*fixWeight + trajRepulseH*trajWeight + goalRepulseH*goalWeight;repulsionV = itemRepulseV*itemWeight + edgeRepulseV*edgeWeight + fixRepulseV*fixWeight + trajRepulseV*trajWeight + goalRepulseV*goalWeight;% temporary variables to test new direciton (make sure doesn't take you% out of bounds)tempDirH = hSpeed+repulsionH;tempDirV = vSpeed+repulsionV;[itemDirection, radius] = GetPolarCoordinates(tempDirH,tempDirV,0,0);% check for out of boundstempH = itemCoordinates_h + itemSpeed .* cos( (itemDirection./180).*pi);tempV = itemCoordinates_v + itemSpeed .* sin( (itemDirection./180).*pi);tempDirH(find(tempH < itemLeft | tempH > itemRight)) = tempDirH(find(tempH < itemLeft | tempH > itemRight))*-1;tempDirV(find (tempV < itemTop | tempV > itemBottom)) = tempDirV(find (tempV < itemTop | tempV > itemBottom))*-1;[itemDirection, radius] = GetPolarCoordinates(tempDirH,tempDirV,0,0);% G. UPDATE ACTUAL COORDINATES ********************************************% update item locationitemCoordinates_h=itemCoordinates_h + itemSpeed .* cos( (itemDirection./180) .*pi);itemCoordinates_v=itemCoordinates_v + itemSpeed .* sin( (itemDirection./180) .*pi);% H. Store Current CoordinatesFILE_TRAJECTORIES(:,:,whichFrame)=[itemCoordinates_h; itemCoordinates_v];% I. AVERAGE AND MINIMUM SPACING%x_rep       = repmat(itemCoordinates_h, length(itemCoordinates_h), 1);%y_rep       = repmat(itemCoordinates_v, length(itemCoordinates_v), 1);%dist        = sqrt((x_rep-x_rep').^2+(y_rep-y_rep').^2);%dist(find(dist == 0))=maxItemDist+itemBuffer*2;%if (find(dist<=itemBuffer))%    MeanMinDist=mean(dist(find(dist<=itemBuffer)))%end% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function ComputeOldRepulsion(whichFrame)global LEFT RIGHT TOP BOTTOMglobal itemCoordinates_h itemCoordinates_v itemGoalPos itemGoalH itemGoalV itemDirection itemSpeed itemSize itemColor itemShape itemIsTarget itemIsProbeglobal numItems centerX centerY% 1. Buffers (minium spacing - used to determine 'bounces') & Display SizeitemBuffer  = 60;            % minimum spacing between items (center to center)edgeBuffer  = 10;            % minimum spacing between item and edge (center of item)fixBuffer   = 60;            % minimum spacing between item and edge (center to center)maxHDist    = RIGHT-LEFT;    % maximum horizontal distancemaxVDist    = BOTTOM-TOP;    % maximum vertical distancemaxItemDist = sqrt( maxHDist*maxHDist + maxVDist*maxVDist);maxFixDist  = sqrt( (maxHDist/2)*(maxHDist/2) + (maxVDist/2)*(maxVDist/2));% 2. Distance ScaleitemScale = 0.07;             % repulsion falls off over distance from itemsedgeScale = 0.07;fixScale  = 0.07;% 3. Compute Repulsion for Each ItemnumItems=8;itemSpeed(1:numItems) = 6 * 32/60; % 6 degrees per second assuming 32 pixels per degree and a 60 Hz refresh ratefor i=1:numItems    % A. Setup*************************************************************    % reset    repulsionV=0;    repulsionH=0;    % repulsion speed    repelSpeed = itemSpeed(i);    % current item's position and speed    h=itemCoordinates_h(i);    v=itemCoordinates_v(i);    hSpeed=cos((itemDirection(i)/180)*pi)*itemSpeed(i);    vSpeed=sin((itemDirection(i)/180)*pi)*itemSpeed(i);    % B. Get Probability of Repulsion from Edges***************************    % distances    dt = v-TOP;    if (dt < edgeBuffer) dt=edgeBuffer; end    db = BOTTOM-v;    if (db < edgeBuffer) db=edgeBuffer; end    dl = h-LEFT;    if (dl < edgeBuffer) dl=edgeBuffer; end    dr = RIGHT-h;    if (dr < edgeBuffer) dr=edgeBuffer; end    % probability of repulsion (0 to 1), based on distance    pt = (1-power((dt-edgeBuffer)/(maxVDist-edgeBuffer),edgeScale)) * 100; % if edgeScale = .5, this is just 1 minus the sqrt of distance/maxDistance shifted so that the equation = 0 when distance = buffer    pb = (1-power((db-edgeBuffer)/(maxVDist-edgeBuffer),edgeScale)) * 100;    pl = (1-power((dl-edgeBuffer)/(maxHDist-edgeBuffer),edgeScale)) * 100;    pr = (1-power((dr-edgeBuffer)/(maxHDist-edgeBuffer),edgeScale)) * 100;    % C. Set Repulsion from Edges Based on Probabilities*******************    % top and bottom    if (pt == 100)        TOP_REPULSE = 1;    elseif (pt == 0)        TOP_REPULSE = 0;    else        if (randInt(1,100) <= pt)            TOP_REPULSE = 1;        else            TOP_REPULSE = 0;        end    end    if (pb == 100)        BOTTOM_REPULSE = 1;    elseif (pb == 0)        BOTTOM_REPULSE = 0;    else        if (randInt(1,100) <= pb)            BOTTOM_REPULSE = 1;        else            BOTTOM_REPULSE = 0;        end    end    % can't have both...    if (TOP_REPULSE == 1 & BOTTOM_REPULSE == 1)        if (dt > db)            TOP_REPULSE     = 0;            BOTTOM_REPULSE  = 1;        else            TOP_REPULSE     = 1;            BOTTOM_REPULSE  = 0;        end    end    % left and right    if (pl == 100)        LEFT_REPULSE = 1;    elseif (pl == 0)        LEFT_REPULSE = 0;    else        if (randInt(1,100) <= pl)            LEFT_REPULSE = 1;        else            LEFT_REPULSE = 0;        end    end    if (pr == 100)        RIGHT_REPULSE = 1;    elseif (pr == 0)        RIGHT_REPULSE = 0;    else        if (randInt(1,100) <= pr)            RIGHT_REPULSE = 1;        else            RIGHT_REPULSE = 0;        end    end    % can't have both...    if (LEFT_REPULSE == 1 & RIGHT_REPULSE == 1)        if (dl > dr)            LEFT_REPULSE     = 0;            RIGHT_REPULSE    = 1;        else            LEFT_REPULSE     = 1;            RIGHT_REPULSE    = 0;        end    end    % C. FINALLY: repulsion strength from edges ***************************    if (TOP_REPULSE)        if (pt == 100)            repulsionV = repulsionV + itemSpeed(i);             % repel by max        else            repulsionV = repulsionV + (repelSpeed * pt/100);    % repel scaled by distance (pt)        end    elseif (BOTTOM_REPULSE)        if (pb == 100)            repulsionV = repulsionV - itemSpeed(i);        else            repulsionV = repulsionV - (repelSpeed * pb/100);        end    end    if (LEFT_REPULSE)        if (pl == 100)            repulsionH = repulsionH + itemSpeed(i);        else            repulsionH = repulsionH + (repelSpeed * pl/100);        end    elseif (RIGHT_REPULSE)        if (pr == 100)            repulsionH = repulsionH - itemSpeed(i);        else            repulsionH = repulsionH - (repelSpeed * pr/100);        end    end    % D. GET ITEM REPULSION ***********************************************    for item=1:numItems        if (item ~= i)            % distances            dh = itemCoordinates_h(item)-h;            dv = itemCoordinates_v(item)-v;            dist = sqrt(dh*dh+dv*dv);            if (dist < itemBuffer) dist=itemBuffer; end            % probabilities of repulsion            p  = (1-power((dist-itemBuffer)/(maxItemDist-itemBuffer),itemScale)) * 100;            ph = (1-power(abs(dh)/(maxHDist),itemScale)) * 100;            pv = (1-power(abs(dv)/(maxVDist),itemScale)) * 100;            % whether or not to repel            if (p == 100)                ITEM_REPULSE = 1;            elseif (p == 0)                ITEM_REPULSE = 0;            else                if (randInt(1,100) <= p)                    ITEM_REPULSE = 1;                else                    ITEM_REPULSE = 0;                end            end            % repulsion            if (ITEM_REPULSE)                if (dh < 0)                    if (p == 100)                        repulsionH = repulsionH + itemSpeed(i);                    else                        repulsionH = repulsionH + (repelSpeed * ph/100);                    end                else                    if (p == 100)                        repulsionH = repulsionH - itemSpeed(i);                    else                        repulsionH = repulsionH - (repelSpeed * ph/100);                    end                end                if (dv < 0)                    if (p == 100)                        repulsionV = repulsionV + itemSpeed(i);                    else                        repulsionV = repulsionV + (repelSpeed * pv/100);                    end                else                    if (p == 100)                        repulsionV = repulsionV - itemSpeed(i);                    else                        repulsionV = repulsionV - (repelSpeed * pv/100);                    end                end            end        end    end    % E. GET FIXATION REPULSION *******************************************    % distances    dh = centerX-h;    dv = centerY-v;    dist = sqrt(dh*dh+dv*dv);    if (dist < fixBuffer) dist=fixBuffer; end    % probabilities of repulsion    p  = (1-power((dist-fixBuffer)/(maxFixDist-fixBuffer),fixScale)) * 100;    ph = (1-power(abs(dh)/(maxHDist/2),fixScale)) * 100;    pv = (1-power(abs(dv)/(maxVDist/2),fixScale)) * 100;    % whether or not to repel    if (p == 100)        FIX_REPULSE = 1;    elseif (p == 0)        FIX_REPULSE = 0;    else        if (randInt(1,100) <= p)            FIX_REPULSE = 1;        else            FIX_REPULSE = 0;        end    end    % repulsion    if (FIX_REPULSE)        if (dh < 0)            if (p == 100)                repulsionH = repulsionH + itemSpeed(i);            else                repulsionH = repulsionH + (repelSpeed * ph/100);            end        else            if (p == 100)                repulsionH = repulsionH - itemSpeed(i);            else                repulsionH = repulsionH - (repelSpeed * ph/100);            end        end        if (dv < 0)            if (p == 100)                repulsionV = repulsionV + itemSpeed(i);            else                repulsionV = repulsionV + (repelSpeed * pv/100);            end        else            if (p == 100)                repulsionV = repulsionV - itemSpeed(i);            else                repulsionV = repulsionV - (repelSpeed * pv/100);            end        end    end    % F. Compute H and V speeds, Then Rescale *****************************    tempHSpeed = hSpeed+repulsionH;    tempVSpeed = vSpeed+repulsionV;    [itemDirection(i), radius] = GetPolarCoordinates(tempHSpeed,tempVSpeed,0,0);    % check for out of bounds    tempH = itemCoordinates_h(i) + itemSpeed(i) * cos( (itemDirection(i)/180)*pi);    tempV = itemCoordinates_v(i) + itemSpeed(i) * sin( (itemDirection(i)/180)*pi);    if (tempH < LEFT | tempH > RIGHT)        tempHSpeed = tempHSpeed*-1;        [itemDirection(i), radius] = GetPolarCoordinates(tempHSpeed,tempVSpeed,0,0);    end    if (tempV < TOP | tempV > BOTTOM)        tempVSpeed = tempVSpeed*-1;        [itemDirection(i), radius] = GetPolarCoordinates(tempHSpeed,tempVSpeed,0,0);    endend% update item locationhDists=itemSpeed .* cos( (itemDirection/180*pi));vDists=itemSpeed .* sin( (itemDirection/180*pi));dists=sqrt (hDists.*hDists + vDists.*vDists);itemCoordinates_h=itemCoordinates_h + itemSpeed .* cos( (itemDirection/180*pi));itemCoordinates_v=itemCoordinates_v + itemSpeed .* sin( (itemDirection/180*pi));% 5. Store Current CoordinatesFILE_TRAJECTORIES(:,:,whichFrame)=[itemCoordinates_h; itemCoordinates_v];% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************function LoadTrialglobal currTrial centerX centerY numTargetsglobal FILE_TRAJECTORIES itemIsTarget itemIsProbe loadTrajectoryDir trajFileName randomsequence% change to folder with trajectory filescd(loadTrajectoryDir);% load trajectory filefileNum = [num2str(randomsequence(currTrial))];trajFileName=['TrackFile_' fileNum '.mat'];load(trajFileName);itemIsTarget;itemIsProbe;numTargets=sum(itemIsTarget);% correct for different screen resolution (if necessary)offsetH = centerX-genCenterX;offsetV = centerY-genCenterY;FILE_TRAJECTORIES(1,:,:)=FILE_TRAJECTORIES(1,:,:)+offsetH;FILE_TRAJECTORIES(2,:,:)=FILE_TRAJECTORIES(2,:,:)+offsetV;% **************************************************************************************************************************************************% **************************************************************************************************************************************************function LoadItemPositions(whichFrame)global FILE_TRAJECTORIES itemCoordinates_h itemCoordinates_vitemCoordinates_h=FILE_TRAJECTORIES(1,:,whichFrame);itemCoordinates_v=FILE_TRAJECTORIES(2,:,whichFrame);% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function DrawFrame()global fid filename expname sinit condnum condname numItems redgreen yesno currTrial currBlock numBlocks numTrialsPerBlock currType randomsequence numtypesglobal condnumArray condnameArray setsizeArray whichoneArray redgreenArray yesnoArray responseArray RTArray errorArrayglobal win1 stimulusWin screenX screenY centerX centerY screenRect activeRect drawWinglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTexture tempTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal TOP BOTTOM LEFT RIGHT itemSizeglobal itemColorglobal itemCoordinates_h itemCoordinates_v numTargetsglobal itemColor itemCorrectColor itemIncorrectColor itemBlankColor FixSize ShowFramesglobal QUADSIZE INSET LLEFT LRIGHT LTOP LBOTTOM RLEFT RRIGHT RTOP RBOTTOM LRECT RRECT AREARECT%clear screen, add fixation pointFillRect(drawWin,bcolor,screenRect);FillOval(drawWin, [0 0 0], [centerX-FixSize centerY-FixSize centerX+FixSize centerY+FixSize]);if (ShowFrames)    FrameRect(drawWin,[0 0 0],LRECT);    FrameRect(drawWin,[0 0 0],RRECT);    FrameRect(drawWin,[0 0 0],AREARECT);end %draw itemsfor item=1:numItems    tempColor   = itemColor(1:3,item)';    radius      = itemSize(item)/2;    tempRect    = [itemCoordinates_h(item)-radius itemCoordinates_v(item)-radius itemCoordinates_h(item)+radius itemCoordinates_v(item)+radius];    FillOval(drawWin, tempColor, tempRect);end    % -------------------------------------------------------------------------% -------------------------------------------------------------------------function SaveFinalMovieFrame()global drawWin win1 bcolor screenRect centerX centerYglobal LEFT RIGHT TOP BOTTOM FixSize ShowFramesglobal itemSize itemColor itemIsTarget itemCoordinates_h itemCoordinates_v numItems frameCount blinkFramesglobal QUADSIZE INSET LLEFT LRIGHT LTOP LBOTTOM RLEFT RRIGHT RTOP RBOTTOM LRECT RRECT AREARECT%clear screen, add fixation pointFillRect(drawWin,bcolor,screenRect);FillOval(drawWin, [0 0 0], [centerX-FixSize centerY-FixSize centerX+FixSize centerY+FixSize]);if (ShowFrames)    FrameRect(drawWin,[0 0 0],LRECT);    FrameRect(drawWin,[0 0 0],RRECT);    FrameRect(drawWin,[0 0 0],AREARECT);end%draw itemsfor item=1:numItems    if (itemIsTarget(item)==1)        tempColor   = [255 0 0];    else        tempColor   = itemColor(1:3,item)';    end        radius      = itemSize(item)/2;    tempRect    = [itemCoordinates_h(item)-radius itemCoordinates_v(item)-radius itemCoordinates_h(item)+radius itemCoordinates_v(item)+radius];    FillOval(drawWin, tempColor, tempRect);end% draw framessaveFrame(frameCount+blinkFrames+1);% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function drawT(i, window, color)global fid filename expname sinit condnum condname numItems redgreen currTrial currBlock numBlocks numTrialsPerBlock currType randomsequence numtypesglobal condnumArray condnameArray setsizeArray whichoneArray redgreenArray responseArray RTArray errorArrayglobal win1 stimulusWin screenX screenY centerX centerY screenRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal itemCoordinates_h itemCoordinates_vthickness = 6;if (itemOrientation(i) == 1)    % left tilted T    h = itemCoordinates_h(i);    v = itemCoordinates_v(i);    size = itemSize(i);    % vertical line (left)    FillRect(window,color,[(h-size/2) (v-size/2) (h-size/2+thickness) (v+size/2)]);    % horizontal line (middle)    FillRect(window,color,[(h-size/2) (v-thickness/2) (h+size/2) (v+thickness/2)]);else                            % right tilted T    h = itemCoordinates_h(i);    v = itemCoordinates_v(i);    size = itemSize(i);    % vertical line (right)    FillRect(window,color,[(h+size/2-thickness) (v-size/2) (h+size/2) (v+size/2)]);    % horizontal line (middle)    FillRect(window,color,[h-size/2 v-thickness/2 h+size/2 v+thickness/2]);end% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function drawL(i, window, color)global fid filename expname sinit condnum condname numItems redgreen currTrial currBlock numBlocks numTrialsPerBlock currType randomsequence numtypesglobal condnumArray condnameArray setsizeArray whichoneArray redgreenArray responseArray RTArray errorArrayglobal win1 stimulusWin screenX screenY centerX centerY screenRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal itemCoordinates_h itemCoordinates_vthickness = 6;if (itemOrientation(i) == 1)    % 0 deg    h = itemCoordinates_h(i);    v = itemCoordinates_v(i);    size = itemSize(i);    % vertical line (left)    FillRect(window,color,[(h-size/2) (v-size/2) (h-size/2+thickness) (v+size/2)]);    % horizontal line (bottom)    FillRect(window,color,[(h-size/2) (v+size/2-thickness) (h+size/2) (v+size/2)]);elseif (itemOrientation(i) == 2)    % 90 deg    h = itemCoordinates_h(i);    v = itemCoordinates_v(i);    size = itemSize(i);    % vertical line (left)    FillRect(window,color,[(h-size/2) (v-size/2) (h-size/2+thickness) (v+size/2)]);    % horizontal line (top)    FillRect(window,color,[(h-size/2) (v-size/2) (h+size/2) (v-size/2+thickness)]);elseif (itemOrientation(i) == 3)    % 180 deg    h = itemCoordinates_h(i);    v = itemCoordinates_v(i);    size = itemSize(i);    % vertical line (right)    FillRect(window,color,[(h+size/2-thickness) (v-size/2) (h+size/2) (v+size/2)]);    % horizontal line (top)    FillRect(window,color,[(h-size/2) (v-size/2) (h+size/2) (v-size/2+thickness)]);elseif (itemOrientation(i) == 4)    % 270 deg    h = itemCoordinates_h(i);    v = itemCoordinates_v(i);    size = itemSize(i);    % vertical line (right)    FillRect(window,color,[(h+size/2-thickness) (v-size/2) (h+size/2) (v+size/2)]);    % horizontal line (bottom)    FillRect(window,color,[(h-size/2) (v+size/2-thickness) (h+size/2) (v+size/2)]);end% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************function which = GetClosestItem(h, v)global itemCoordinates_h itemCoordinates_v itemIsSelected% find distancestempH = itemCoordinates_h;tempV = itemCoordinates_v;tempH(find(itemIsSelected==1))=999999999999999;tempV(find(itemIsSelected==1))=999999999999999;hDist = tempH-h;vDist = tempV-v;dist    = sqrt (hDist.*hDist + vDist.*vDist);which = find(dist==min(dist),1);% **************************************************************************************************************************************************% **************************************************************************************************************************************************function CheckClickAccuracy(which)global itemIsSelected itemIsTarget numCorrectSoFar numSoFar clickAccuracy clickRT% current item has been selecteditemIsSelected(which)=1;% if correct, increment accuracy countif (itemIsTarget(which)==1)    numCorrectSoFar=numCorrectSoFar+1;    clickAccuracy(numSoFar)=1;end% **************************************************************************************************************************************************% **************************************************************************************************************************************************function HighlightClosestItem(which)global itemIsSelected drawWin win1 bcolor itemCoordinates_h itemCoordinates_v screenRect centerX centerY itemSize LEFT RIGHT TOP BOTTOM itemIsTarget itemIsSelected numItemsglobal itemColor itemCorrectColor itemIncorrectColor itemBlankColor FixSize ShowFramesglobal QUADSIZE INSET LLEFT LRIGHT LTOP LBOTTOM RLEFT RRIGHT RTOP RBOTTOM LRECT RRECT AREARECT%clear screen, add fixation pointFillRect(drawWin,bcolor,screenRect);FillOval(drawWin, [0 0 0], [centerX-FixSize centerY-FixSize centerX+FixSize centerY+FixSize]);if (ShowFrames)    FrameRect(drawWin,[0 0 0],LRECT);    FrameRect(drawWin,[0 0 0],RRECT);    FrameRect(drawWin,[0 0 0],AREARECT);end% change color of closest itemitemIsClosest(1:numItems)=0;itemIsClosest(which)=1;highlightColor  =[200 200 0];correctColor    =[0 255 0];incorrectColor  =[255 0 0];otherColor      =[0 0 0];% draw accuracy feedbackfor item=1:numItems        if (itemIsSelected(item)==1 & itemIsTarget(item)==1)        tempColor   = correctColor;        radius      = itemSize(item)/2*1.25;        tempRect    = [itemCoordinates_h(item)-radius itemCoordinates_v(item)-radius itemCoordinates_h(item)+radius itemCoordinates_v(item)+radius];        FillRect(drawWin, tempColor, tempRect);    elseif (itemIsSelected(item)==1 & itemIsTarget(item)==0)        tempColor   = incorrectColor;        radius      = itemSize(item)/2*1.25;        tempRect    = [itemCoordinates_h(item)-radius itemCoordinates_v(item)-radius itemCoordinates_h(item)+radius itemCoordinates_v(item)+radius];        FillRect(drawWin, tempColor, tempRect);    end    end% draw itemsfor item=1:numItems        if (itemIsClosest(item)==1)        tempColor   = highlightColor;    else        tempColor   = otherColor;    end        radius      = itemSize(item)/2;    tempRect    = [itemCoordinates_h(item)-radius itemCoordinates_v(item)-radius itemCoordinates_h(item)+radius itemCoordinates_v(item)+radius];    FillOval(drawWin, tempColor, tempRect);endShowScreen(drawWin, screenRect);% **************************************************************************************************************************************************% **************************************************************************************************************************************************function BlinkTargetItems(blinkFrames)global itemIsSelected drawWin win1 bcolor itemCoordinates_h itemCoordinates_v screenRect centerX centerY itemSize LEFT RIGHT TOP BOTTOM itemIsTarget itemIsSelected numItemsglobal makeMovieglobal itemColor itemCorrectColor itemIncorrectColor itemBlankColor FixSize ShowFramesglobal QUADSIZE INSET LLEFT LRIGHT LTOP LBOTTOM RLEFT RRIGHT RTOP RBOTTOM LRECT RRECT AREARECT% blink the targetsonColor             =[0 0 0];offColor            =bcolor;correctColor        =[0 255 0];incorrectColor      =[255 0 0];itemOnProportion    = .5;cycleFrames         =  30;for i=1:blinkFrames    %clear screen, add fixation point and frame    FillRect(drawWin,bcolor,screenRect);    FillOval(drawWin, [0 0 0], [centerX-FixSize centerY-FixSize centerX+FixSize centerY+FixSize]);    if (ShowFrames)        FrameRect(drawWin,[0 0 0],LRECT);        FrameRect(drawWin,[0 0 0],RRECT);        FrameRect(drawWin,[0 0 0],AREARECT);    end        % draw accuracy feedback    for item=1:numItems        if (itemIsSelected(item)==1 & itemIsTarget(item)==1)            tempColor   = correctColor;            radius      = itemSize(item)/2*1.25;            tempRect    = [itemCoordinates_h(item)-radius itemCoordinates_v(item)-radius itemCoordinates_h(item)+radius itemCoordinates_v(item)+radius];            FillRect(drawWin, tempColor, tempRect);        elseif (itemIsSelected(item)==1 & itemIsTarget(item)==0)            tempColor   = incorrectColor;            radius      = itemSize(item)/2*1.25;            tempRect    = [itemCoordinates_h(item)-radius itemCoordinates_v(item)-radius itemCoordinates_h(item)+radius itemCoordinates_v(item)+radius];            FillRect(drawWin, tempColor, tempRect);        end            end    % draw items    if (mod(i,cycleFrames) <= cycleFrames*itemOnProportion)        for item=1:numItems            tempColor   = onColor;            radius      = itemSize(item)/2;            tempRect    = [itemCoordinates_h(item)-radius itemCoordinates_v(item)-radius itemCoordinates_h(item)+radius itemCoordinates_v(item)+radius];            FillOval(drawWin, tempColor, tempRect);        end    else                        for item=1:numItems            if (itemIsTarget(item)==1)                tempColor   = offColor;            else                tempColor   = onColor;            end            radius      = itemSize(item)/2;            tempRect    = [itemCoordinates_h(item)-radius itemCoordinates_v(item)-radius itemCoordinates_h(item)+radius itemCoordinates_v(item)+radius];            FillOval(drawWin, tempColor, tempRect);        end    end    if (makeMovie)  saveFrame(i); end      % save as jpg file (SLOW!!!!!!!!!!!!!!!!)    % show items    ShowScreen(drawWin, screenRect);end%clear screen, add fixation point and frameFillRect(drawWin,bcolor,screenRect);FillOval(drawWin, [0 0 0], [centerX-FixSize centerY-FixSize centerX+FixSize centerY+FixSize]);if (ShowFrames)    FrameRect(drawWin,[0 0 0],LRECT);    FrameRect(drawWin,[0 0 0],RRECT);    FrameRect(drawWin,[0 0 0],AREARECT);end% draw accuracy feedbackfor item=1:numItems        if (itemIsSelected(item)==1 & itemIsTarget(item)==1)        tempColor   = correctColor;        radius      = itemSize(item)/2*1.25;        tempRect    = [itemCoordinates_h(item)-radius itemCoordinates_v(item)-radius itemCoordinates_h(item)+radius itemCoordinates_v(item)+radius];        FillRect(drawWin, tempColor, tempRect);    elseif (itemIsSelected(item)==1 & itemIsTarget(item)==0)        tempColor   = incorrectColor;        radius      = itemSize(item)/2*1.25;        tempRect    = [itemCoordinates_h(item)-radius itemCoordinates_v(item)-radius itemCoordinates_h(item)+radius itemCoordinates_v(item)+radius];        FillRect(drawWin, tempColor, tempRect);    end end% draw itemsfor item=1:numItems    tempColor   = onColor;    radius      = itemSize(item)/2;    tempRect    = [itemCoordinates_h(item)-radius itemCoordinates_v(item)-radius itemCoordinates_h(item)+radius itemCoordinates_v(item)+radius];    FillOval(drawWin, tempColor, tempRect);end% show itemsShowScreen(drawWin, screenRect);    %t1=GetSecs;%while (GetSecs-t1<.5) end% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function DisplayStimuli()global win1 blankWin fixWin drawWin stimulusWin activeRect centerX centerY bcolor screenRect FixSizeglobal startTime RT global itemCoordinates_h itemCoordinates_v itemGoalPos itemGoalH itemGoalV itemDirection itemSpeed itemSize itemColor itemShape itemIsTarget itemIsProbeglobal runMode makeMovie saveTrajectories currTrialglobal FILE_TRAJECTORIES itemIsTargetglobal itemIsSelected numItems global numCorrectSoFar percentCorrectglobal DisplayDuration NewFrameTime NewRefreshRate DrawTime numberDroppedglobal frameCount blinkFrames RefreshRateglobal ExperimentStartTime BlockStartTime TrialStartTime FixationDuration BlinkDuration TrackDuration ResponseDuration TrialDuration FeedbackDurationglobal SHOWFRAMES LRECT RRECT AREARECT itemColor itemSize itemSpeed ShowFrames yesno condnum% 1. initialize some variablesitemIsSelected(1:numItems)  = 0;RT                          = 0;numCorrectSoFar             = 0;percentCorrect              = 0;% 2. Show Fixation Point for 8 SecondsShowScreen(fixWin, [centerX-centerY centerY-centerY centerX+centerY centerY+centerY]);while (GetSecs-TrialStartTime(currTrial)<FixationDuration) end% 4. Blink Items to Designate TargetsComputeFrame(1);blinkFrames = msecsToFrames(BlinkDuration*1000);BlinkTargetItems(blinkFrames);% 5. Compute/Draw Frames% setupnumFrames = msecsToFrames(TrackDuration*1000);                  % number of frames to showpriorityLevel=MaxPriority(win1);                                % minimize system interuptions by giving MATLAB max priorityPriority(priorityLevel);                                        % set priority to maxframeCount=0;                                                   % counter for number of frames drawn/computed% show framesfor i=1:numFrames        t1=GetSecs;                                                 % start time (for tracking compute/draw time)    frameCount = frameCount+1;                                  % iterate frame count    ComputeFrame(frameCount);                                   % compute current frame (e.g., item locations/appearance)        %___________________________________________________________    %clear screen, add fixation point    FillRect(drawWin,bcolor,screenRect);    FillOval(drawWin, [0 0 0], [centerX-FixSize centerY-FixSize centerX+FixSize centerY+FixSize]);    if (ShowFrames)        FrameRect(drawWin,[0 0 0],LRECT);        FrameRect(drawWin,[0 0 0],RRECT);        FrameRect(drawWin,[0 0 0],AREARECT);    end    %draw items    for item=1:numItems        tempColor   = itemColor(1:3,item)';        radius      = itemSize(item)/2;        tempRect    = [itemCoordinates_h(item)-radius itemCoordinates_v(item)-radius itemCoordinates_h(item)+radius itemCoordinates_v(item)+radius];        FillOval(drawWin, tempColor, tempRect);    end    drawTime(i)=GetSecs-t1;                                      % time required to compute/draw this frame    %____________________________________________________________            %____________________________________________________________    if (makeMovie)  saveFrame(frameCount+blinkFrames); end       % save as jpg file (SLOW!!!!!!!!!!!!!!!!)        Screen('Flip',win1);        timeStamp(i) = GetSecs;                                     % track timing    %___________________________________________________________        endPriority(0);                                                    % set priority back to zero% DISPLAY TEST ITEM%clear screen, add fixation pointFillRect(drawWin,bcolor,screenRect);FillOval(drawWin, [0 0 0], [centerX-FixSize centerY-FixSize centerX+FixSize centerY+FixSize]);if (ShowFrames)    FrameRect(drawWin,[0 0 0],LRECT);    FrameRect(drawWin,[0 0 0],RRECT);    FrameRect(drawWin,[0 0 0],AREARECT);end% highlight randomly selected itemif (yesno == 0)    targColor       =[0 0 0];          distColor       =[255 0 0];     % highlight distractorelse    targColor       =[255 0 0];      % highlight target    distColor       =[0 0 0]; endotherColor      =[0 0 0];for item=1:numItems    if (condnum==1)        if (itemIsProbe(item)==1)            tempColor=[255 0 0];        else            tempColor=[0 0 0];        end    else        if (itemIsProbe(item)==1 & itemIsTarget(item)==1)            tempColor=targColor;        elseif (itemIsProbe(item)==1 & itemIsTarget(item)==0)            tempColor=distColor;        else            tempColor=otherColor;        end    end    radius      = itemSize(item)/2;    tempRect    = [itemCoordinates_h(item)-radius itemCoordinates_v(item)-radius itemCoordinates_h(item)+radius itemCoordinates_v(item)+radius];    FillOval(drawWin, tempColor, tempRect);endScreen('Flip',win1);startTime=GetSecs;% 6. check timingDisplayDuration = (timeStamp(frameCount)-timeStamp(1))*1000;    % total duration that the display was shown in the loop above (ms)NewFrameTime    = median(diff(timeStamp))*1000;                 % median time between frames (ms)NewRefreshRate  = 1/(NewFrameTime/1000);                        % nominal refreshrate (Hz)DrawTime        = median(drawTime)*1000;                        % average amount of time required to draw the stimulus frams (ms)droppedFrames=find(diff(timeStamp)*1000 > 20);                  % assumes 60 hznumberDropped=length(droppedFrames);% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function saveFrame(whichFrame)global win1 currTrial activeRect movieDirglobal LEFT RIGHT TOP BOTTOM;cd(movieDir);imageArray=screen('GetImage', win1, [LEFT-200 TOP-8 RIGHT+200 BOTTOM+8]);if (whichFrame < 10)    imageName=['Trial_000' num2str(whichFrame) '.jpg'];elseif (whichFrame < 100)    imageName=['Trial_00' num2str(whichFrame) '.jpg'];elseif (whichFrame < 1000)    imageName=['Trial_0' num2str(whichFrame) '.jpg'];elseif (whichFrame < 10000)    imageName=['Trial_' num2str(whichFrame) '.jpg'];endimwrite(imageArray,imageName,'jpg');% -------------------------------------------------------------------------% **************************************************************************************************************************************************% **************************************************************************************************************************************************function GetTrackingResponse()global responseMode TrialStartTime currTrialswitch responseMode    case 1        GetClickTargets;        % get mouse clicks    case 2        GetWhichoneResponse;    % get speeded key response (which highlighted item is the target?)    case 3        GetTDResponse;          % get speeded key response (is the highlighted item a target?)end        % **************************************************************************************************************************************************% **************************************************************************************************************************************************function GetWhichoneResponse()global drawWin win1 bcolor screenRect centerX centerY LEFT TOP RIGHT BOTTOM numItemsglobal itemIsProbe itemIsTarget itemCoordinates_h itemCoordinates_v itemSizeglobal redgreen Key1 Key2 QuitKey startTime response RT trackError numberCorrect percentCorrectglobal whichKeyboard FixSize ShowFramesglobal QUADSIZE INSET LLEFT LRIGHT LTOP LBOTTOM RLEFT RRIGHT RTOP RBOTTOM LRECT RRECT AREARECT%clear screen, add fixation pointFillRect(drawWin,bcolor,screenRect);FillOval(drawWin, [0 0 0], [centerX-FixSize centerY-FixSize centerX+FixSize centerY+FixSize]);if (ShowFrames)    FrameRect(drawWin,[0 0 0],LRECT);    FrameRect(drawWin,[0 0 0],RRECT);    FrameRect(drawWin,[0 0 0],AREARECT);end% change color of target and distractorhighlightColor  =[200 200 0];if (redgreen==1)        targColor =[255 0 0]; % red target    distColor =[0 255 0];else    targColor =[0 255 0]; % green target    distColor =[255 0 0];     endotherColor      =[0 0 0];for item=1:numItems    if (itemIsProbe(item)==1 & itemIsTarget(item)==1)        tempColor=targColor;    elseif (itemIsProbe(item)==1 & itemIsTarget(item)==0)        tempColor=distColor;    else        tempColor=otherColor;    end    radius      = itemSize(item)/2;    tempRect    = [itemCoordinates_h(item)-radius itemCoordinates_v(item)-radius itemCoordinates_h(item)+radius itemCoordinates_v(item)+radius];    FillOval(drawWin, tempColor, tempRect);endShowScreen(drawWin, screenRect);startTime=GetSecs;% get the responseresponse=999;                                   % make response some numberwhile (1)                                       %  klkkkqq    [keyIsDown,secs,keyCode] = KbCheck([whichKeyboard]);         % check for a keypress    if keyIsDown                                % if there is a keypress        RT=(GetSecs-startTime)*1000;            % save RT        response=find(keyCode);                 % save response        response=response(1);        if (response == Key1 | response == Key2 | response == QuitKey)            break;        end    endendClearKeys;% check accuracyif (redgreen == 1)    if (response == Key1)        trackError = 0;    else        trackError = 1;    endelse    if (response == Key2)        trackError = 0;    else        trackError = 1;    endendif (response ~= QuitKey)    GiveFeedback;endClearKeys;% **************************************************************************************************************************************************% **************************************************************************************************************************************************function GetTDResponse()global condnum win1 drawWin bcolor screenRect centerX centerY LEFT TOP RIGHT BOTTOM numItemsglobal itemIsProbe itemIsTarget itemCoordinates_h itemCoordinates_v itemSize startTimeglobal yesno Key1 Key2 QuitKey startTime response RT trackError numberCorrect percentCorrectglobal whichKeyboard RefreshRate currTrial FixSize ShowFramesglobal QUADSIZE INSET LLEFT LRIGHT LTOP LBOTTOM RLEFT RRIGHT RTOP RBOTTOM LRECT RRECT AREARECTglobal ExperimentStartTime BlockStartTime TrialStartTime FixationDuration BlinkDuration TrackDuration ResponseDuration TrialDuration FeedbackDuration% get the responseresponse=999; % make response some numberwhile ( (GetSecs-startTime) < 10.0) % loop until keypress    [keyIsDown,secs,keyCode] = KbCheck([whichKeyboard]);                        % check for a keypress    if keyIsDown                                                                % if there is a keypress        RT=(GetSecs-startTime)*1000;                                            % save RT        response=find(keyCode);                                                 % save response        response=response(1);        if (response == Key1 | response == Key2 | response == QuitKey)            break;        end    endendClearKeys;% check accuracyif (yesno == 1)    if (response == Key1)        trackError = 0;    else        trackError = 1;    endelse    if (response == Key2)        trackError = 0;    else        trackError = 1;    endendif (response ~= QuitKey)    GiveFeedback;endClearKeys;% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function GetClickTargets()global fid filename expname sinit condnum condname numItems redgreen currTrial currBlock numBlocks numTrialsPerBlock currType randomsequence numtypesglobal condnumArray condnameArray setsizeArray whichoneArray redgreenArray responseArray RTArray errorArrayglobal win1 stimulusWin screenX screenY centerX centerY screenRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal itemIsSelected numCorrectSoFar numSoFar clickAccuracy clickRT screenNumber numTargets global MAXTARGETSglobal whichKeyboard% initialize some variablesnumSoFar                        =  0;response                        =999;numCorrectSoFar                 =  0;clickAccuracy(1:MAXTARGETS)     =  0;clickRT(1:MAXTARGETS)           =  0;% move the mouse to the centerScreen('SetMouseHelper', screenNumber, centerX, centerY);% make sure mouse is not currently presed[x,y,buttons] = GetMouseMulti(screenNumber);while any(buttons) % if already down, wait for release    [x,y,buttons] = GetMouseMulti(screenNumber);end% wait for mouse to move[tempx,tempy,buttons] = GetMouseMulti(screenNumber);[x,y,buttons] = GetMouseMulti(screenNumber);while (tempx==x & tempy==y) % if already down, wait for release    [x,y,buttons] = GetMouseMulti(screenNumber);        %check for quit key    [keyIsDown,secs,keyCode] = KbCheck([whichKeyboard]);        % check for a keypress    if keyIsDown                                                % if there is a keypress        response=find(keyCode);                                 % save response        response=response(1);                                       if (response == QuitKey)            break;        end    endend% get the responsewhile (1)                                                           %check for quit key    [keyIsDown,secs,keyCode] = KbCheck([whichKeyboard]);        % check for a keypress    if keyIsDown                                                % if there is a keypress        response=find(keyCode);                                 % save response        response=response(1);        if (response == QuitKey)            break;        end    end    % check mouse position    [x,y,buttons] = GetMouseMulti(screenNumber);    while ~any(buttons) % wait for press        [x,y,buttons] = GetMouseMulti(screenNumber);            % check for mouse click (using home-made getmouse)        which=GetClosestItem(x,y);                              % determine which item is currently closest to mouse        HighlightClosestItem(which);                            % highlight that item        %check for quit key        [keyIsDown,secs,keyCode] = KbCheck([whichKeyboard]);    % check for a keypress        if keyIsDown                                            % if there is a keypress            response=find(keyCode);                             % save response            response=response(1);            if (response == QuitKey)                break;            end        end    end        downPress=GetSecs;                                          % record time for mouse press    numSoFar=numSoFar+1;                                        % increment count of the number of clicks so far    clickRT(numSoFar) = (downPress-startTime)*1000;             % compute time since last click (or since start)    startTime=downPress;                                        % reset start time to time of last click        while any(buttons)                                          % wait for button release                   [x,y,buttons] = GetMouseMulti(screenNumber);        %check for quit key        [keyIsDown,secs,keyCode] = KbCheck([whichKeyboard]);    % check for a keypress        if keyIsDown                                            % if there is a keypress            response=find(keyCode);                             % save response            response=response(1);            if (response == QuitKey)                break;            end        end    end    CheckClickAccuracy(which);                                  % check the accuracy of this click    HighlightClosestItem(which);                                % mark the clicked item    if (numSoFar == numTargets)        break;    end    endif (response ~= QuitKey)    blinkFrames=120;    BlinkTargetItems(blinkFrames);    percentCorrect=numCorrectSoFar/numTargets*100;    if (percentCorrect == 100)        trackError = 0;    else        trackError = 1;    endendClearKeys;% **************************************************************************************************************************************************% **************************************************************************************************************************************************function DoubleCheckQuitKey()global drawWin quitWin blankWin response activeRect screenRectglobal whichKeyboard bcolor response TextFontSize% show feedback for half a secondFillRect(drawWin,bcolor,screenRect);TextSize(drawWin,round(TextFontSize*.8));textStr = 'IF YOU REALLY WANT TO QUIT, PRESS ''Q''';[textX, textY] = CenterText(drawWin,screenRect,textStr,30);DrawText(drawWin, textStr, textX, textY-30, [0 0 0]);textStr = 'OTHERWISE PRESS ANY OTHER KEY';[textX, textY] = CenterText(drawWin,screenRect,textStr,30);DrawText(drawWin, textStr, textX, textY+30, [0 0 0]);quitTexture=MakeTexture(drawWin, activeRect);ShowScreen(drawWin, activeRect);% wait till key is not pressed[keyIsDown,secs,keyCode] = KbCheck([whichKeyboard]);             % check for a keypresswhile any(keyIsDown)                            % loop until keypress    [keyIsDown,secs,keyCode] = KbCheck([whichKeyboard]);         % check for a keypressend% get the responsewhile (1)                                       % loop until keypress    %check for quit key    [keyIsDown,secs,keyCode] = KbCheck([whichKeyboard]);         % check for a keypress    if keyIsDown                                % if there is a keypress        response=find(keyCode);                 % save response        response=response(1);        break;    endendShowScreen(blankWin, activeRect);ClearKeys;% **************************************************************************************************************************************************% **************************************************************************************************************************************************% -------------------------------------------------------------------------function GiveFeedback()global fid filename expname sinit condnum condname numItems redgreen currTrial currBlock numBlocks currType randomsequence numtypesglobal condnumArray condnameArray setsizeArray whichoneArray redgreenArray responseArray RTArray errorArrayglobal win1 drawWin blankWin tempWin fixWin stimulusWin screenX screenY centerX centerY screenRect activeRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTexture tempTextureglobal meanRT stdRT meanError slope intercept FixSize ShowFramesglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal ExperimentStartTime BlockStartTime TrialStartTime FixationDuration BlinkDuration TrackDuration ResponseDuration TrialDuration FeedbackDurationglobal trackErrorglobal LRECT RRECT AREARECT TrialStartTime currTrial% draw feedbackFillRect(drawWin,bcolor,screenRect);if (ShowFrames)    FrameRect(drawWin,[0 0 0],LRECT);    FrameRect(drawWin,[0 0 0],RRECT);    FrameRect(drawWin,[0 0 0],AREARECT);endif (trackError == 1)    FillOval(drawWin, [255 0 0], [centerX-FixSize centerY-FixSize centerX+FixSize centerY+FixSize]);else    FillOval(drawWin, [0 255 0], [centerX-FixSize centerY-FixSize centerX+FixSize centerY+FixSize]);endtempTexture=MakeTexture(drawWin, activeRect);ShowScreen(drawWin, activeRect);TextureClose(tempTexture);t1=GetSecs; while ((GetSecs-t1) < FeedbackDuration) end% **************************************************************************************************************************************************% **************************************************************************************************************************************************function EndOfSessionMessage()global fid filename expname sinit condnum condname setsize leftright currTrial currBlock numBlocks currType randomsequence numtypesglobal condnumArray condnameArray setsizeArray whichoneArray leftrightArray responseArray RTArray errorArrayglobal win1 blankWin tempWin fixWin stimulusWin drawWin screenX screenY centerX centerY screenRect activeRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize setsize yesno whichoneglobal Key1 Key2 startTime RT response errorglobal blankTexture fixTexture stimulusTexture tempTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir TextFontSize% draw feedbackFillRect(drawWin,bcolor,screenRect);TextSize(drawWin,TextFontSize);textStr = 'END OF SESSION';[textX, textY] = CenterText(drawWin,screenRect,textStr,36);DrawText(drawWin, textStr, textX, textY-30, [0 0 0]);textStr = 'THANK YOU FOR PARTICIPATING!';[textX, textY] = CenterText(drawWin,screenRect,textStr,36);DrawText(drawWin, textStr, textX, textY+30, [0 0 0]);endTexture=MakeTexture(drawWin, activeRect);% show feedback for half a secondt1=GetSecs;ShowScreen(drawWin, activeRect);while (GetSecs-t1<1.5) endTextureClose(tempTexture);% show a blank screen for half a secondShowScreen(blankWin, [centerX-centerY centerY-centerY centerX+centerY centerY+centerY]);% **************************************************************************************************************************************************% **************************************************************************************************************************************************%%           DATA SAVING FUNCTIONS%% **************************************************************************************************************************************************% **************************************************************************************************************************************************function SetupResults()global fid filename expname sinit condnum condname numItems redgreen currTrial currBlock numBlocks numTrialsPerBlock currType randomsequence numtypesglobal condnumArray condnameArray setsizeArray whichoneArray redgreenArray responseArray RTArray errorArrayglobal win1 stimulusWin screenX screenY centerX centerY screenRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal uniqueID responseMode MAXITEMS MAXTARGETS% get unique file name, open .xls file for recording datacd(dataDir);filename = [sinit '_' expname '.xls'];                              % current file namexlsfiles = dir('*.xls');   											% get mat file names in this directorynames={};if (size(xlsfiles,1) > 0)    [names{1:size(xlsfiles)}]=deal(xlsfiles.name);                  % cell array containing names of .mat filesenduniqueID=sinit;while(~isempty(find(strcmp(names,filename)))) % make sure this filename is unique    randomNum=randInt(1,100);    uniqueID=[sinit num2str(randomNum)];    filename=[uniqueID '_' expname '.xls'];end% setup folders to save file information with unique idmkdir(trialDir, uniqueID);mkdir(saveTrajectoryDir, uniqueID);trialDir=[trialDir '/' uniqueID];saveTrajectoryDir=[saveTrajectoryDir '/' uniqueID];% open filefid = fopen(filename,'a'); % Name of the result file% basic header informationtime=clock;time=[num2str(time(4)) ':' num2str(time(5))];fprintf(fid,'------------------------------------------------------------------------------------\n');fprintf(fid,'EXPERIMENT:\t%s\n',expname);fprintf(fid,'DATE:\t%s\n',date);fprintf(fid,'TIME:\t%s\n',time);fprintf(fid,'SUBJECT:\t%s\n',sinit);fprintf(fid,'------------------------------------------------------------------------------------\n\n');% column headers for text file% 'expname'         : name of the experiment% 'sinit'           : subject's initials% 'currBlock'       : current block number% 'currTrial'       : current trial number% 'condnum'         : number corresponding to current condition% 'condname'        : name of current condition% 'numItems'        : number of items in the display% 'itemSpeed'       : how fast the items move% 'numTargets'      : number of target itemsfprintf(fid,'%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t', 'expname', 'sinit', 'currBlock', 'currTrial', 'currFile', 'condnum', 'condname', 'numItems', 'itemSpeed', 'numTargets');% additional headers, depending on response modeif (responseMode == 1)      % click targets        fprintf(fid,'%s\t%s\t%s\t', 'trackError', 'numCorrect', 'percentCorrect');    for i=1:MAXTARGETS        fprintf(fid,'%s\t', ['clickAccuracy' num2str(i)]);    end    for i=1:MAXTARGETS        fprintf(fid,'%s\t', ['clickRT' num2str(i)]);    end    fprintf(fid,'\n');elseif (responseMode == 2)  % which probe is the traget    fprintf(fid,'%s\t%s\t%s\t%s\t%s\t\n', 'testside', 'redgreen', 'response', 'RT', 'trackError');elseif (responseMode == 3)  % is the probe a target    fprintf(fid,'%s\t%s\t%s\t%s\t%s\t\n', 'testside', 'yesno', 'response', 'RT', 'trackError');end% **************************************************************************************************************************************************% **************************************************************************************************************************************************function RecordTrialResults()global fid filename expname sinit condnum condname numItems redgreen probefield currTrial currBlock numBlocks numTrialsPerBlock currType randomsequence numtypesglobal condnumArray condnameArray numTargetsArray redgreenArray yesnoArray trackRTArray numCorrectArray trackErrorArray percentCorrectArray responseArray RTArray errorArrayglobal win1 stimulusWin screenX screenY centerX centerY screenRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemIsProbe itemIsSelected itemShape itemOrientation itemSize itemColor itemSpeed numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numCorrectSoFar percentCorrectglobal blankTexture fixTexture stimulusTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal FILE_TRAJECTORIES itemIsTargetglobal saveTrajectory responseMode ITEMSPEEDglobal clickAccuracy clickRT numTargets MAXTARGETSglobal DisplayDuration NewFrameTime NewRefreshRate DrawTime numberDroppedglobal trajFileNameglobal ExperimentStartTime BlockStartTime TrialStartTime FixationDuration BlinkDuration TrackDuration ResponseDuration TrialDuration FeedbackDuration% 1. RECORD DATA IN EXCEL FILEfprintf(fid,'%s\t%s\t%d\t%d\t%s\t%d\t%s\t%d\t%d\t%d\t', expname, sinit, currBlock, currTrial, char(trajFileName), condnum, condname, numItems, ITEMSPEED, numTargets);if (responseMode == 1)    fprintf(fid,'%d\t%d\t%f\t', trackError, numCorrectSoFar, percentCorrect);    for i=1:MAXTARGETS        fprintf(fid,'%d\t', clickAccuracy(i));    end    for i=1:MAXTARGETS        fprintf(fid,'%f\t', clickRT(i));    end    fprintf(fid,'\n');elseif (responseMode == 2)  % which probe is the traget    fprintf(fid,'%d\t%d\t%d\t%f\t%d\t\n', probefield, redgreen, response, RT, trackError);elseif (responseMode == 3)  % is the probe a target    fprintf(fid,'%d\t%d\t%d\t%f\t%d\t\n', probefield, yesno, response, RT, trackError);end% 2. STORE DATA IN ARRAYS (to use for subsequent data analysis)condnumArray(currTrial)         = condnum;condnameArray{currTrial}        = condname;numTargetsArray(currTrial)      = numTargets;redgreenArray(currTrial)        = redgreen;yesnoArray(currTrial)           = yesno;trackRTArray(currTrial)         = RT;trackErrorArray(currTrial)      = trackError;numCorrectArray(currTrial)      = numCorrectSoFar;percentCorrectArray(currTrial)  = percentCorrect;% 3. RECORD DATA IN MAT FILES (duplicates text file, but has other stuff% like item trajectories, etc., for complete record)cd(trialDir);% save results and display in mat file (who, what, where...this information shoud be sufficient to recreate the display for this trial EXACTLY!!)switch responseMode    case 1        save ([filename(1:end-4) '_' num2str(currTrial) '.mat'], 'expname', 'sinit', 'currBlock', 'currTrial', 'trajFileName', 'condnum', 'condname', 'numItems', 'ITEMSPEED', 'numTargets', 'trackError', 'numCorrectSoFar','percentCorrect','clickAccuracy', 'clickRT', 'itemIsSelected', 'itemIsTarget', 'itemShape', 'itemSize', 'itemColor', 'itemSpeed', 'screenRect', 'centerX', 'centerY', 'DisplayDuration', 'NewFrameTime', 'NewRefreshRate', 'DrawTime', 'numberDropped');    case 2        save ([filename(1:end-4) '_' num2str(currTrial) '.mat'], 'expname', 'sinit', 'currBlock', 'currTrial', 'trajFileName', 'condnum', 'condname', 'numItems', 'ITEMSPEED', 'numTargets', 'redgreen', 'response', 'RT','trackError','itemIsTarget', 'itemIsProbe', 'itemShape', 'itemSize', 'itemColor', 'itemSpeed', 'screenRect', 'centerX', 'centerY', 'DisplayDuration', 'NewFrameTime', 'NewRefreshRate', 'DrawTime', 'numberDropped');    case 3        save ([filename(1:end-4) '_' num2str(currTrial) '.mat'], 'expname', 'sinit', 'currBlock', 'currTrial', 'trajFileName', 'condnum', 'condname', 'numItems', 'ITEMSPEED', 'numTargets', 'yesno', 'response', 'RT','trackError','itemIsTarget', 'itemIsProbe', 'itemShape', 'itemSize', 'itemColor', 'itemSpeed', 'screenRect', 'centerX', 'centerY', 'DisplayDuration', 'NewFrameTime', 'NewRefreshRate', 'DrawTime', 'numberDropped');end% 4. SAVE TRAJECTORY FILESif (saveTrajectory)    cd(saveTrajectoryDir);    newTrajFileName=['TrackFile_' num2str(currTrial) '.mat'];    genCenterX=centerX; % save center position (in case different resolution used when running from this file)    genCenterY=centerY; % saving with new name so wont overwrite actual centerX, centerY when loaded    save (newTrajFileName, 'FILE_TRAJECTORIES', 'itemIsTarget', 'itemIsProbe', 'genCenterX', 'genCenterY'); % with this info should be able to reproduce trajectories exactly!end% continue to show feedback until trial is overwhile ((GetSecs-ExperimentStartTime) < (TrialDuration*currTrial)) end% **************************************************************************************************************************************************% **************************************************************************************************************************************************function ComputeSummaryStatistics()global fid filename expname sinit condnum condname numItems redgreen currTrial currBlock numBlocks numTrialsPerBlock currType randomsequence numtypesglobal Array condnameArray setsizeArray whichoneArray redgreenArray responseArray RTArray trackErrorArray yesnoArray numTargetsArray percentCorrectArrayglobal win1 stimulusWin screenX screenY centerX centerY screenRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal numItems responseModeglobal meanPercentCorrect meanError meanHitRate meanFARate CapacityVsNumTargets AsymptoteEstimateglobal MAXTARGETS% independent variables in this experimentCapacityVsNumTargets(1:MAXTARGETS)=0;AsymptoteEstimate                 =0;conditions=[1];             % condition numberscondnames = {'One'};        % condition namesxvalues=[1 2 3 4 5];        % for this experiment, these values correspond to the number of targets% compute means for each combination of independent variablefor cond=1:length(conditions)    for x=1:length(xvalues)        meanPercentCorrect(cond,x)   = mean(percentCorrectArray(find(numTargetsArray==xvalues(x) & condnumArray==conditions(cond))));        meanError(cond,x)            = mean(trackErrorArray(find(numTargetsArray==xvalues(x) & condnumArray==conditions(cond))));         meanHitRate(cond,x)          = 1-mean(trackErrorArray(find(yesnoArray==1 & numTargetsArray==xvalues(x) & condnumArray==conditions(cond))));        meanFARate(cond,x)           = mean(trackErrorArray(find(yesnoArray==0 & numTargetsArray==xvalues(x) & condnumArray==conditions(cond))));    endend% compute capacityswitch responseMode    case 1        [CapacityVsNumTargets, AsymptoteEstimate] = ComputeClickCapacity(numItems, xvalues, meanPercentCorrect, 1, 0);    case 2        [CapacityVsNumTargets, AsymptoteEstimate] = ComputeWhichoneCapacity(numItems, xvalues, 1-meanError, 1, 0);    case 3        [CapacityVsNumTargets, AsymptoteEstimate] = ComputeTDCapacity(numItems, xvalues, meanHitRate, meanFARate, 1, 0)end% print values in command windowRows = condnames'Columns = xvaluesCapacityVsNumTargetsAsymptoteEstimate% **************************************************************************************************************************************************% **************************************************************************************************************************************************function SaveFinalResults()global fid filename expname sinit condnum condname numItems redgreen currTrial currBlock numBlocks numTrialsPerBlock currType randomsequence numtypesglobal win1 stimulusWin screenX screenY centerX centerY screenRectglobal MASTER_COORDINATES_h MASTER_COORDINATES_v LEFT_COORDINATES_h LEFT_COORDINATES_v RIGHT_COORDINATES_h RIGHT_COORDINATES_v Coordinates_h Coordinates_vglobal LAYOUT RADIUS NUM_POSITIONS HORIZONTAL_POSITIONS VERTICAL_POSITIONS RESERVE_FIXATION HORIZONTAL_EXTENT VERTICAL_EXTENT SPACING X_SIZE Y_SIZE JITTER X_JITTER Y_JITTER HEMI_BUFFER HEMI_NUM_RINGS HEMI_NUM_PER_RINGglobal bcolor items itemIsTarget itemIsProbe itemIsTarget itemColor itemShape itemOrientation itemSize numItems yesno whichoneglobal Key1 Key2 QuitKey startTime RT response trackError numberCorrect percentCorrectglobal blankTexture fixTexture stimulusTextureglobal meanRT stdRT meanError slope interceptglobal d dataDir trialDir imageDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal responseModeglobal condnumArray condnameArray numTargetsArray redgreenArray yesnoArray trackRTArray trackErrorArray numCorrectArray percentCorrectArrayglobal meanPercentCorrect meanError meanHitRate meanFARate CapacityVsNumTargets AsymptoteEstimate% change to data directorycd(dataDir);% add basic header informationtime=clock;time=[num2str(time(4)) ':' num2str(time(5))];fprintf(fid,'\n------------------------------------------------------------------------------------\n');fprintf(fid,'END DATE:\t%s\n',date);fprintf(fid,'END TIME:\t%s\n',time);fprintf(fid,'------------------------------------------------------------------------------------\n');% VARIABLE DESCRIPTIONS% 'expname'             : name of the experiment% 'sinit'               : subject's initials%%  for all arrays, each column represents a single trial% 'condnumArray'        : array with condition number% 'condnameArray'       : array with condition name% 'numTargetsArray'     : array with number of targets% 'redgreenArray'       : array with target color% 'yesnoArray'          : array with identity of probed item% 'trackRTArray'        : array with reaction time (in milliseconds)% 'trackErrorArray'     : array with error (1 = error, 0 = no error, so mean(error) gives the average error rate% 'numCorrectArray'     : array with number of correctly clicked targets% 'percentCorrectArray' : array with percent of correctly clicked targets% be careful not to overwrite an existing .mat filefilename = [filename(1:end-4) '.mat'];% save fileswitch responseMode    case 1        save (filename, 'expname', 'sinit', 'condnumArray', 'condnameArray', 'numTargetsArray', 'redgreenArray', 'yesnoArray', 'trackRTArray', 'trackErrorArray', 'numCorrectArray', 'percentCorrectArray', 'meanError', 'meanPercentCorrect','CapacityVsNumTargets','AsymptoteEstimate');    case 2        save (filename, 'expname', 'sinit', 'condnumArray', 'condnameArray', 'numTargetsArray', 'redgreenArray', 'yesnoArray', 'trackRTArray', 'trackErrorArray', 'meanError','CapacityVsNumTargets','AsymptoteEstimate');    case 3        save (filename, 'expname', 'sinit', 'condnumArray', 'condnameArray', 'numTargetsArray', 'redgreenArray', 'yesnoArray', 'trackRTArray', 'trackErrorArray', 'meanError', 'meanHitRate', 'meanFARate','CapacityVsNumTargets','AsymptoteEstimate');end% **************************************************************************************************************************************************% **************************************************************************************************************************************************%%           OSX - OS9 - WINDOWS Compatability Functions%% **************************************************************************************************************************************************% **************************************************************************************************************************************************function OpenMainWindow()global win1 screenX screenY screenRect screenNumber drawWin% this function opens the main screen% MAC OSXwin1=Screen('OpenWindow',screenNumber,0,[],32,2);[screenX, screenY]=Screen('WindowSize', win1);screenRect  =[0 0 screenX screenY];% MAC OS 9%[win1, screenRect]=Screen(0,'OpenWindow',0,[],32);%screenX = screenRect(3);%screenY = screenRect(4);% WINDOWS%[win1, screenRect]=Screen(0,'OpenWindow',0,[],32);%screenX = screenRect(3);%screenY = screenRect(4);% -------------------------------------------------------------------------% -------------------------------------------------------------------------function GetDrawWindow()global win1 screenX screenY screenRect screenNumber drawWin stimulusWin% this function opens the main screen% MAC OSXdrawWin=win1;% MAC OS 9%drawWin=stimulusWin(1);% WINDOWS%drawWin=stimulusWin(1);% -------------------------------------------------------------------------% -------------------------------------------------------------------------function [newX, newY] = CenterText(window,drawRect,textStr,height)% purpose: center text string (textStr) drawRect% MAC OSX[normBoundsRect, offsetBoundsRect]= Screen('TextBounds', window, textStr);[newRect,dh,dv] = CenterRect(normBoundsRect,drawRect);newX = newRect(1,1);newY = newRect(1,2);% MAC OS9%width=SCREEN(window,'TextWidth',textStr);%h=drawRect(1,1) + (drawRect(1,3)-drawRect(1,1))/2; % horizontal center of rect%v=drawRect(1,2) + (drawRect(1,4)-drawRect(1,2))/2; % vertical center of rect%newX = h-width/2;%newY = v-height/2;% WINDOWS%width=SCREEN(window,'TextWidth',textStr);%h=drawRect(1,1) + (drawRect(1,3)-drawRect(1,1))/2; % horizontal center of rect%v=drawRect(1,2) + (drawRect(1,4)-drawRect(1,2))/2; % vertical center of rect%newX = h-width/2;%newY = v-height/2;% -------------------------------------------------------------------------% -------------------------------------------------------------------------function FillRect(window, color, rect)global win1 blankWin fixWin tempWin stimulusWin drawWin% this funciton fills a rect in the specified window% MAC OSXScreen('FillRect', window, color, rect);% MAC OS9%Screen(window,'FillRect',color,rect)% WINDOWS%Screen(window,'FillRect',color,rect);% -------------------------------------------------------------------------% -------------------------------------------------------------------------function FrameRect(window, color, rect)global win1 blankWin fixWin tempWin stimulusWin drawWin% this funciton fills a rect in the specified window% MAC OSXScreen('FrameRect', window, color, rect);% MAC OS9%Screen(window,'FrameRect',color,rect)% WINDOWS%Screen(window,'FrameRect',color,rect);% -------------------------------------------------------------------------% -------------------------------------------------------------------------function FillOval(window, color, rect)global win1 blankWin fixWin tempWin stimulusWin drawWin% this funciton fills a rect in the specified window% MAC OSXScreen('FillOval', window, color, rect);% MAC OS9%Screen(window,'FillOval',color,rect)% WINDOWS%Screen(window,'FillOval',color,rect);% -------------------------------------------------------------------------% -------------------------------------------------------------------------function ShowMain()global win1 blankWin fixWin tempWin stimulusWin drawWin% this function shows the mains screen (only for double buffered windows)% MAC OSXScreen('Flip',win1);% MAC OS9% WINDOWS% -------------------------------------------------------------------------% -------------------------------------------------------------------------function window=OpenOffscreenWindow(win,color,rect,pixelSize)global win1 blankWin fixWin tempWin stimulusWin drawWin% this function shows the mains screen (only for double buffered windows)% MAC OSXwindow=Screen('OpenOffscreenWindow',win1,[],rect,pixelSize);% MAC OS9%window=Screen(win1,'OpenOffscreenWindow',color,rect,pixelSize);% WINDOWS%window=Screen(win1,'OpenOffscreenWindow',color,rect,pixelSize);% -------------------------------------------------------------------------% -------------------------------------------------------------------------function textureIndex=MakeTexture(window, rect)global win1 blankWin fixWin tempWin stimulusWin drawWin% this function makes a texture out of an image window% MAC OSXtempArray=Screen('GetImage', window, rect);             % slowest funciton in the history of time. takes about .5 seconds to read a 500 x 500 pixel image into an arraytextureIndex=Screen('MakeTexture', win1, tempArray);    % light speed by comparison (1.14e+05)% MAC OS9%textureIndex=0;% WINDOWS%textureIndex=0;% -------------------------------------------------------------------------% -------------------------------------------------------------------------function TextSize(window, fontsize)global win1 blankWin fixWin tempWin stimulusWin drawWin% this function makes a texture out of an image window% MAC OSXScreen('TextSize', window, fontsize);% MAC OS9%Screen(window,'TextSize',fontsize);% WINDOWS%Screen(window,'TextSize',fontsize);% -------------------------------------------------------------------------% -------------------------------------------------------------------------function DrawText(window, string, x, y, color)global win1 blankWin fixWin tempWin stimulusWin drawWin% this function makes a texture out of an image window% MAC OSXScreen('DrawText', window, string, x, y, color, []);% MAC OS9%Screen(window, 'DrawText', string, x, y, color);% WINDOWS%Screen(window, 'DrawText', string, x, y, color);% -------------------------------------------------------------------------% -------------------------------------------------------------------------function ShowScreen(window, rect)global win1 blankWin fixWin tempWin trialWin tempWin stimulusWin endWin quitWinglobal blankTexture fixTexture trialTexture tempTexture endTexture quitTexture% this function shows the current window% MAC OSXif (window == win1)    Screen('Flip',win1);elseif (window == blankWin)    Screen('DrawTexture', win1, blankTexture);    Screen('Flip',win1);elseif (window == fixWin)    Screen('DrawTexture', win1, fixTexture);    Screen('Flip',win1);elseif (window == tempWin)    Screen('DrawTexture', win1, tempTexture);    Screen('Flip',win1);elseif (window == trialWin)    Screen('DrawTexture', win1, trialTexture);    Screen('Flip',win1);elseif (window == endWin)    Screen('DrawTexture', win1, endTexture);    Screen('Flip',win1);elseif (window == quitWin)    Screen('DrawTexture', win1, quitTexture);    Screen('Flip',win1);elseif (window == stimulusWin(1))    Screen('DrawTexture', win1, tempTexture);    Screen('Flip',win1);end% MAC OS9%SCREEN('WaitBlanking',win1,1)%Screen('CopyWindow',window,win1,[],[],[]);% WINDOWS%SCREEN(win1,'WaitBlanking',1);%Screen('CopyWindow',window,win1,[],[],[]);% -------------------------------------------------------------------------% -------------------------------------------------------------------------function TextureClose(whichTexture)global win1 blankWin fixWin tempWin trialWin tempWin stimulusWin blankTexture fixTexture trialTexture tempTexture% this function shows the current window% MAC OSXScreen('Close',whichTexture);% MAC OS9% ignored% WINDOWS% ignored% -------------------------------------------------------------------------% -------------------------------------------------------------------------function GetRefreshRate()global win1 RefreshRate% this function shows the current window% MAC OSXRefreshRate=Screen('NominalFrameRate', win1);RefreshRate=60;% MAC OS9% WINDOWS% -------------------------------------------------------------------------% ------------------GetDirectories-------------------------------------------------------function GetDirectories()global win1 blankWin fixWin tempWin tempWin stimulusWinglobal d dataDir trialDir imageDir movieDir loadTrajectoryDir saveTrajectoryDir parameterSettingDirglobal uniqueID% this sets up directories for data, trial records, and image files% MAC OSXd=pwd; %'/Users/george/Documents/RESEARCH/EXPERIMENTS/2005/Collaborations/TRACKING - Lorella/MOT HEMIFIELDS - TMS 1';dataDir=[d '/DataFiles'];imageDir=[d '/ImageFiles'];movieDir=[d '/MovieFiles'];loadTrajectoryDir=[d '/PrecomputedTrajectoryFiles'];trialDir=[d '/TrialFiles/TrialData'];saveTrajectoryDir=[d '/TrialFiles/TrajectoryFiles'];cd(d);% MAC OS9%d='Alhazen:Users:GEORGES STUFF:PROGRAMMING:MATLAB TEMPLATE';%dataDir=[d ':DataFiles'];%trialDir=[d ':TrialFiles'];%imageDir=[d ':ImageFiles'];%cd(d);% WINDOWS%d='C:\Documents and Settings\Aude\My Documents\George''s Experiments\Experiment Template\';%dataDir=[d '\DataFiles'];%trialDir=[d '\TrialFiles'];%imageDir=[d '\ImageFiles'];%cd(d);% -------------------------------------------------------------------------% -------------------------------------------------------------------------function ClearKeys()% this funciton clears the command window% MAC OSX%clc;% MAC OS9%clc;%FlushEvents('keyDown');% WINDOWS% -------------------------------------------------------------------------